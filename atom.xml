<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[乐皓博客]]></title>
  <link href="http://www.ilehao.com/atom.xml" rel="self"/>
  <link href="http://www.ilehao.com/"/>
  <updated>2014-02-25T17:31:26+08:00</updated>
  <id>http://www.ilehao.com/</id>
  <author>
    <name><![CDATA[乐皓]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[git blog R&amp;Q]]></title>
    <link href="http://www.ilehao.com/blog/2014/02/21/git-blog-r-and-q/"/>
    <updated>2014-02-21T14:38:00+08:00</updated>
    <id>http://www.ilehao.com/blog/2014/02/21/git-blog-r-and-q</id>
    <content type="html"><![CDATA[<p>一、rake gen_deploy时提示版本不对</p>

<pre><code>To https://github.com/username/username.github.io
! [rejected] master -&amp;gt; master (non-fast-forward)
error: failed to push some refs to 'https://github.com/username/username.github.io'
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Merge the remote changes (e.g. 'git pull')
hint: before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
</code></pre>

<p>按以下步骤操作:</p>

<pre><code>git clone https://github.com/username/username.github.io.git
git checkout source

mkdir _deploy
cd _deploy
git init
git remote add -t master -f origin https://github.com/username/username.github.io.git
</code></pre>

<p>现在再试下 <code>rake gen_deploy</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[alibaba招聘]]></title>
    <link href="http://www.ilehao.com/blog/2014/02/20/zhaopin/"/>
    <updated>2014-02-20T10:07:00+08:00</updated>
    <id>http://www.ilehao.com/blog/2014/02/20/zhaopin</id>
    <content type="html"><![CDATA[<pre><code>alibaba招聘目标层级是P6及以上高级java开发工程师，具体的要求见下：
1.JAVA基础扎实，熟悉io、多线程、集合等基础框架，熟悉分布式、缓存、消息、搜索等机制；
2.两年以上使用java进行web开发的经验，熟练使用spring 、MVC等框架，熟悉Linux下的常用命令，熟悉MySQL；
3.熟悉常用设计模式，有大型分布式、高并发、高负载、高可用性系统设计开发经验；
4.熟悉或精通脚本语言：如python\shell\php等
5.具有一定的项目规划和决策能力，善于捕捉业务需求、架构设计中存在的问题，并给出有效的解决措施和方法；
6.具有良好的抽象设计能力，思路清晰，善于思考，能独立分析和解决问题,责任心强，具备良好的团队合作精神和承受压力的能力。
有兴趣的请email：marke.chenj@alibaba-inc.com
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[spring]]></title>
    <link href="http://www.ilehao.com/blog/2013/08/30/spring/"/>
    <updated>2013-08-30T17:31:00+08:00</updated>
    <id>http://www.ilehao.com/blog/2013/08/30/spring</id>
    <content type="html"><![CDATA[<p>spring</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java SE 8: Lambda 表达式]]></title>
    <link href="http://www.ilehao.com/blog/2013/08/30/java-se-8-lambda/"/>
    <updated>2013-08-30T09:04:00+08:00</updated>
    <id>http://www.ilehao.com/blog/2013/08/30/java-se-8-lambda</id>
    <content type="html"><![CDATA[<p>Java SE 8在6月13的版本中已经完全了全部的功能。在这些新的功能中，lambda表达式是推动该版本发布的最重要新特性。因为Java第一次尝试引入函数式编程的相关内容。社区对于lambda表达式也期待已久。Lambda表达式的相关内容在JSR 335中定义，本文的内容基于最新的规范和JDK 8 Build b94。 开发环境使用的是Eclipse。</p>

<p>Lambda表达式</p>

<p>要理解lambda表达式，首先要了解的是函数式接口（functional interface）。简单来说，函数式接口是只包含一个抽象方法的接口。比如Java标准库中的java.lang.Runnable和java.util.Comparator都是典型的函数式接口。对于函数式接口，除了可以使用Java中标准的方法来创建实现对象之外，还可以使用lambda表达式来创建实现对象。这可以在很大程度上简化代码的实现。在使用lambda表达式时，只需要提供形式参数和方法体。由于函数式接口只有一个抽象方法，所以通过lambda表达式声明的方法体就肯定是这个唯一的抽象方法的实现，而且形式参数的类型可以根据方法的类型声明进行自动推断。</p>

<p>以Runnable接口为例来进行说明，传统的创建一个线程并运行的方式如下所示：</p>

<pre><code>public void runThread() {
    new Thread(new Runnable() {
    public void run() {
        System.out.println("Run!");
    }
    }).start();
}
</code></pre>

<p>在上面的代码中，首先需要创建一个匿名内部类实现Runnable接口，还需要实现接口中的run方法。如果使用lambda表达式来完成同样的功能，得到的代码非常简洁，如下面所示：</p>

<pre><code>public void runThreadUseLambda() {
    new Thread(() -&gt; {
    System.out.println("Run!");
    }).start();
}
</code></pre>

<p>相对于传统的方式，lambda表达式在两个方面进行了简化：首先是Runnable接口的声明，这可以通过对上下文环境进行推断来得出；其次是对run方法的实现，因为函数式接口中只包含一个需要实现的方法。</p>

<p>Lambda表达式的声明方式比较简单，由形式参数和方法体两部分组成，中间通过“->”分隔。形式参数不需要包含类型声明，可以进行自动推断。当然在某些情况下，形式参数的类型声明是不可少的。方法体则可以是简单的表达式或代码块。</p>

<p>比如把一个整数列表按照降序排列可以用下面的代码来简洁实现：</p>

<pre><code>Collections.sort(list, (x, y) -&gt; y - x);
</code></pre>

<p>Lambda表达式“(x, y) &ndash;> y &ndash; x“实现了java.util.Comparator接口。</p>

<p>在Java SE 8之前的标准库中包含的函数式接口并不多。Java SE 8增加了java.util.function包，里面都是可以在开发中使用的函数式接口。开发人员也可以创建新的函数式接口。最好在接口上使用注解@FunctionalInterface进行声明，以免团队的其他人员错误地往接口中添加新的方法。</p>

<p>下面的代码使用函数式接口java.util.function.Function实现的对列表进行map操作的方法。从代码中可以看到，如果尽可能的使用函数式接口，则代码使用起来会非常简洁。</p>

<pre><code>public class CollectionUtils {
    public static  List map(List input, Function processor) {
    ArrayList result = new ArrayList();
    for (T obj : input) {
        result.add(processor.apply(obj));
    }
    return result;
    }

    public static void main(String[] args) {
    List input = Arrays.asList(new String[] {"apple", "orange", "pear"});
    List lengths = CollectionUtils.map(input, (String v) -&gt; v.length());
    List uppercases = CollectionUtils.map(input, (String v) -&gt; v.toUpperCase());
    }
}
</code></pre>

<p>方法和构造方法引用</p>

<p>方法引用可以在不调用某个方法的情况下引用一个方法。构造方法引用可以在不创建对象的情况下引用一个构造方法。方法引用是另外一种实现函数式接口的方法。在某些情况下，方法引用可以进一步简化代码。比如下面的代码中，第一个forEach方法调用使用的是lambda表达式，第二个使用的是方法引用。两者作用相同，不过使用方法引用的做法更加简洁。</p>

<pre><code>List input = Arrays.asList(new String[] {"apple", "orange", "pear"});
input.forEach((v) -&gt; System.out.println(v));
input.forEach(System.out::println);
</code></pre>

<p>构造方法可以通过名称“new”来进行引用，如下面的代码所示：</p>

<pre><code>List dateValues = Arrays.asList(new Long[] {0L, 1000L});
List dates = CollectionUtils.map(dateValues, Date::new);
</code></pre>

<p>接口的默认方法</p>

<p>Java开发中所推荐的实践是面向接口而不是实现来编程。接口作为不同组件之间的契约，使得接口的实现可以不断地演化。不过接口本身的演化则比较困难。当接口发生变化时，该接口的所有实现类都需要做出相应的修改。如果在新版本中对接口进行了修改，会导致早期版本的代码无法运行。Java对于接口更新的限制过于严格。在代码演化的过程中，一般所遵循的原则是不删除或修改已有的功能，而是添加新的功能作为替代。已有代码可以继续使用原有的功能，而新的代码则可以使用新的功能。但是这种更新方式对于接口是不适用的，因为往一个接口中添加新的方法也会导致已有代码无法运行。</p>

<p>接口的默认方法的主要目标之一是解决接口的演化问题。当往一个接口中添加新的方法时，可以提供该方法的默认实现。对于已有的接口使用者来说，代码可以继续运行。新的代码则可以使用该方法，也可以覆写默认的实现。</p>

<p>考虑下面的一个简单的进行货币转换的接口。该接口的实现方式可能是调用第三方提供的服务来完成实际的转换操作。</p>

<pre><code>public interface CurrencyConverter {
    BigDecimal convert(Currency from, Currency to, BigDecimal amount);
}
</code></pre>

<p>该接口在开发出来之后，在应用中得到了使用。在后续的版本更新中，第三方服务提供了新的批量处理的功能，允许在一次请求中同时转换多个数值。最直接的做法是在原有的接口中添加一个新的方法来支持批量处理，不过这样会造成已有的代码无法运行。而默认方法则可以很好的解决这个问题。使用默认方法的新接口如下所示。</p>

<pre><code>public interface CurrencyConverter {
    BigDecimal convert(Currency from, Currency to, BigDecimal amount);

    default List convert(Currency from, Currency to, List amounts) {
    List result = new ArrayList();
        for (BigDecimal amount : amounts) {
        result.add(convert(from, to, amount));
        }
        return result;
    }
}
</code></pre>

<p>新添加的方法使用default关键词来修饰，并可以有自己的方法体。</p>

<p>默认方法的另外一个作用是实现行为的多继承。Java语言只允许类之间的单继承关系，但是一个类可以实现多个接口。在默认方法引入之后，接口中不仅可以包含变量和方法声明，还可以包含方法体，也就是行为。通过实现多个接口，一个Java类实际上可以获得来自不同接口的行为。这种功能类似于JavaScript等其他语言中可见的“混入类”（mixin）。实际上，Java中一直存在“常量接口（Constant Interface）”的用法。常量接口中只包含常量的声明。通过实现这样的接口，就可以直接引用这些常量。通过默认方法，可以创建出类似的帮助接口，即接口中包含的都是通过默认方法实现的帮助方法。比如创建一个StringUtils接口包含各种与字符串操作相关的默认方法。通过继承该接口就可以直接使用这些方法。</p>

<p>Java SE 8标准库已经使用默认方法来对集合类中的接口进行更新。比如java.util.Collection接口中新增的默认方法removeIf可以删除集合中满足某些条件的元素。还有java.lang.Iterable接口中新增的默认方法forEach可以遍历集合中的元素，并执行一些操作。这些新增的默认方法大多使用了java.util.function包中的函数式接口，因此可以使用lambda表达式来非常简洁的进行操作。</p>

<p>Lambda表达式是Java SE 8在提高开发人员生产效率上的一个重大改进。通过语法上的改进，可以减少开发人员需要编写和维护的代码数量。<br>
转载：<a href="http://www.infoq.com/cn/articles/Java-se-8-lambda">http://www.infoq.com/cn/articles/Java-se-8-lambda</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[curl command]]></title>
    <link href="http://www.ilehao.com/blog/2013/08/29/curl-command/"/>
    <updated>2013-08-29T10:12:00+08:00</updated>
    <id>http://www.ilehao.com/blog/2013/08/29/curl-command</id>
    <content type="html"><![CDATA[<p>一、查看网页源码
直接在curl命令后加上网址，就可以看到网页源码。我们以网址www.sina.com为例（选择该网址，主要因为它的网页代码较短）：</p>

<pre><code>curl www.sina.com
</code></pre>

<p>　　<code>&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;
　　&lt;html&gt;&lt;head&gt;
　　&lt;title&gt;301 Moved Permanently&lt;/title&gt;
　　&lt;/head&gt;&lt;body&gt;
　　&lt;h1&gt;Moved Permanently&lt;/h1&gt;
　　&lt;p&gt;The document has moved &lt;a href="http://www.sina.com.cn/"&gt;here&lt;/a&gt;.&lt;/p&gt;
　　&lt;/body&gt;&lt;/html&gt;</code>
如果要把这个网页保存下来，可以使用-o参数，这就相当于使用wget命令了。</p>

<pre><code>curl -o [文件名] www.sina.com
</code></pre>

<p>二、自动跳转
有的网址是自动跳转的。使用-L参数，curl就会跳转到新的网址。</p>

<pre><code>curl -L www.sina.com
</code></pre>

<p>键入上面的命令，结果就自动跳转为www.sina.com.cn。
三、显示头信息
-i参数可以显示http response的头信息，连同网页代码一起。</p>

<pre><code>curl -i www.sina.com
</code></pre>

<p>　　<code>HTTP/1.0 301 Moved Permanently
　　Date: Sat, 03 Sep 2011 23:44:10 GMT
　　Server: Apache/2.0.54 (Unix)
　　Location: http://www.sina.com.cn/
　　Cache-Control: max-age=3600
　　Expires: Sun, 04 Sep 2011 00:44:10 GMT
　　Vary: Accept-Encoding
　　Content-Length: 231
　　Content-Type: text/html; charset=iso-8859-1
　　Age: 3239
　　X-Cache: HIT from sh201-9.sina.com.cn
　　Connection: close
　　&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;
　　&lt;html&gt;&lt;head&gt;
　　&lt;title&gt;301 Moved Permanently&lt;/title&gt;
　　&lt;/head&gt;&lt;body&gt;
　　&lt;h1&gt;Moved Permanently&lt;/h1&gt;
　　&lt;p&gt;The document has moved &lt;a href="http://www.sina.com.cn/"&gt;here&lt;/a&gt;.&lt;/p&gt;
　　&lt;/body&gt;&lt;/html&gt;</code>
-I参数则是只显示http response的头信息。
四、显示通信过程
-v参数可以显示一次http通信的整个过程，包括端口连接和http request头信息。
　　curl -v www.sina.com
　<code>　* About to connect() to www.sina.com port 80 (#0)
　　* Trying 61.172.201.195... connected
　　* Connected to www.sina.com (61.172.201.195) port 80 (#0)
　　&gt; GET / HTTP/1.1
　　&gt; User-Agent: curl/7.21.3 (i686-pc-linux-gnu) libcurl/7.21.3 OpenSSL/0.9.8o zlib/1.2.3.4 libidn/1.18
　　&gt; Host: www.sina.com
　　&gt; Accept: */*
　　&gt;
　　* HTTP 1.0, assume close after body
　　&lt; HTTP/1.0 301 Moved Permanently
　　&lt; Date: Sun, 04 Sep 2011 00:42:39 GMT
　　&lt; Server: Apache/2.0.54 (Unix)
　　&lt; Location: http://www.sina.com.cn/
　　&lt; Cache-Control: max-age=3600
　　&lt; Expires: Sun, 04 Sep 2011 01:42:39 GMT
　　&lt; Vary: Accept-Encoding
　　&lt; Content-Length: 231
　　&lt; Content-Type: text/html; charset=iso-8859-1
　　&lt; X-Cache: MISS from sh201-19.sina.com.cn
　　&lt; Connection: close
　　&lt;
　　&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;
　　&lt;html&gt;&lt;head&gt;
　　&lt;title&gt;301 Moved Permanently&lt;/title&gt;
　　&lt;/head&gt;&lt;body&gt;
　　&lt;h1&gt;Moved Permanently&lt;/h1&gt;
　　&lt;p&gt;The document has moved &lt;a href="http://www.sina.com.cn/"&gt;here&lt;/a&gt;.&lt;/p&gt;
　　&lt;/body&gt;&lt;/html&gt;
　　* Closing connection #0</code>
如果你觉得上面的信息还不够，那么下面的命令可以查看更详细的通信过程。</p>

<pre><code>curl --trace output.txt www.sina.com
</code></pre>

<p>或者</p>

<pre><code>curl --trace-ascii output.txt www.sina.com
</code></pre>

<p>运行后，请打开output.txt文件查看。
五、发送表单信息
发送表单信息有GET和POST两种方法。GET方法相对简单，只要把数据附在网址后面就行。</p>

<pre><code>curl example.com/form.cgi?data=xxx
</code></pre>

<p>POST方法必须把数据和网址分开，curl就要用到&mdash;data参数。</p>

<pre><code>curl --data "data=xxx" example.com/form.cgi
</code></pre>

<p>如果你的数据没有经过表单编码，还可以让curl为你编码，参数是&mdash;data-urlencode。</p>

<pre><code>curl --data-urlencode "date=April 1" example.com/form.cgi
</code></pre>

<p>六、HTTP动词
curl默认的HTTP动词是GET，使用-X参数可以支持其他动词。</p>

<pre><code>curl -X POST www.example.com
curl -X DELETE www.example.com
</code></pre>

<p>七、文件上传
假定文件上传的表单是下面这样：
　　<code>&lt;form method="POST" enctype='multipart/form-data' action="upload.cgi"&gt;
　　　　&lt;input type=file name=upload&gt;
　　　　&lt;input type=submit name=press value="OK"&gt;
　　&lt;/form&gt;</code>
你可以用curl这样上传文件：</p>

<pre><code>curl --form upload=@localfilename --form press=OK [URL]
</code></pre>

<p>八、Referer字段
有时你需要在http request头信息中，提供一个referer字段，表示你是从哪里跳转过来的。</p>

<pre><code>curl --referer http://www.example.com http://www.example.com
</code></pre>

<p>九、User Agent字段
这个字段是用来表示客户端的设备信息。服务器有时会根据这个字段，针对不同设备，返回不同格式的网页，比如手机版和桌面版。
iPhone4的User Agent是
　　Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_0 like Mac OS X; en-us) AppleWebKit/532.9 (KHTML, like Gecko) Version/4.0.5 Mobile/8A293 Safari/6531.22.7
curl可以这样模拟：</p>

<pre><code>curl --user-agent "[User Agent]" [URL]
</code></pre>

<p>十、cookie
使用&mdash;cookie参数，可以让curl发送cookie。</p>

<pre><code>curl --cookie "name=xxx" www.example.com
</code></pre>

<p>至于具体的cookie的值，可以从http response头信息的Set-Cookie字段中得到。
十一、增加头信息
有时需要在http request之中，自行增加一个头信息。&mdash;header参数就可以起到这个作用。</p>

<pre><code>curl --header "xxx: xxxxxx" http://example.com
</code></pre>

<p>十二、HTTP认证
有些网域需要HTTP认证，这时curl需要用到&mdash;user参数。</p>

<pre><code>curl --user name:password example.com
curl www.sina.com view page
curl -o index.html www.sina.com download page
curl -L www.sina.com redirect page
curl -i www.sina.com view head&amp;content
curl -v www.sina.com traceinfo
curl --trace output.txt www.sina.com
curl --trace-ascii output.txt www.sina.com
</code></pre>

<p>登录到认证页面：</p>

<pre><code>openssl pkcs12 -in  key.pfx -out all.pem -nodes
curl -L -s -k --cert all.pem www.xxx.com
</code></pre>

<p>常用curl实例</p>

<p>1，抓取页面内容到一个文件中</p>

<pre><code>curl -o home.html http://www.ilehao.com
</code></pre>

<p>2，用-O（大写的），后面的url要具体到某个文件，不然抓不下来。我们还可以用正则来抓取东西</p>

<pre><code>curl -O http://www.ilehao.com/images/blogImgs/rtb.jpg
curl -O http://www.ilehao.com/images/blogImgs/[a-z].jpg
</code></pre>

<p>3，模拟表单信息，模拟登录，保存cookie信息</p>

<pre><code>curl -c ./cookie_c.txt -F log=aaaa -F pwd=****** http://www.ilehao.com
</code></pre>

<p>4，模拟表单信息，模拟登录，保存头信息</p>

<pre><code>curl -D ./cookie_D.txt -F log=aaaa -F pwd=****** http://www.ilehao.com
</code></pre>

<p>-c(小写)产生的cookie和-D里面的cookie是不一样的。</p>

<p>5，使用cookie文件</p>

<pre><code>curl -b ./cookie_c.txt  http://www.ilehao.com
</code></pre>

<p>6，断点续传，-C(大写的)</p>

<pre><code>curl -C -O http://www.ilehao.com/wp-content/uploads/2010/09/compare_varnish.jpg
</code></pre>

<p>7，传送数据,最好用登录页面测试，因为你传值过去后，curl回抓数据，你可以看到你传值有没有成功</p>

<pre><code>curl -d log=aaaa  http://www.ilehao.com/wp-login.php
</code></pre>

<p>8，显示抓取错误，下面这个例子，很清楚的表明了。</p>

<pre><code>curl -f http://www.ilehao.com/asdf
curl: (22) The requested URL returned error: 404
curl http://www.ilehao.com/asdf
</code></pre>

<p><code>&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;404,not found&lt;/TITLE&gt;
。。。。。。。。。。。。</code></p>

<p>9，伪造来源地址，有的网站会判断，请求来源地址。</p>

<pre><code>curl -e http://localhost http://www.ilehao.com
</code></pre>

<p>10，当我们经常用curl去搞人家东西的时候，人家会把你的IP给屏蔽掉的,这个时候,我们可以用代理</p>

<pre><code>curl -x 24.10.28.84:32779 -o home.html http://www.ilehao.com
</code></pre>

<p>11，比较大的东西，我们可以分段下载</p>

<pre><code>curl -r 0-100 -o img.part1 http://www.ilehao.com/wp-content/uploads/2010/09/compare_varnish.jpg
</code></pre>

<p><code>% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
Dload  Upload   Total   Spent    Left  Speed
100   101  100   101    0     0    105      0 --:--:-- --:--:-- --:--:--     0
curl -r 100-200 -o img.part2 http://www.ilehao.com/wp-content/uploads/2010/09/compare_varnish.jpg
% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
Dload  Upload   Total   Spent    Left  Speed
100   101  100   101    0     0     57      0  0:00:01  0:00:01 --:--:--     0
curl -r 200- -o img.part3 http://www.ilehao.com/wp-content/uploads/2010/09/compare_varnish.jpg
% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
Dload  Upload   Total   Spent    Left  Speed
100  104k  100  104k    0     0  52793      0  0:00:02  0:00:02 --:--:-- 88961
ls |grep part | xargs du -sh
4.0K    one.part1
112K    three.part3
4.0K    two.part2</code>
用的时候，把他们cat一下就OK了,cat img.part* >img.jpg</p>

<pre><code>curl -s -o aaa.jpg  http://www.ilehao.com/wp-content/uploads/2010/09/compare_varnish.jpg
</code></pre>

<p>13，显示下载进度条</p>

<pre><code>curl -# -O  http://www.ilehao.com/wp-content/uploads/2010/09/compare_varnish.jpg
</code></pre>

<h6>################################################################## 100.0%</h6>

<p>14,通过ftp下载文件</p>

<pre><code>curl -u 用户名:密码 -O http://www.ilehao.com/demo/curtain/bbstudy_files/style.css
</code></pre>

<p><code>% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
Dload  Upload   Total   Spent    Left  Speed
101  1934  101  1934    0     0   3184      0 --:--:-- --:--:-- --:--:--  7136</code></p>

<p>或者用下面的方式</p>

<pre><code>curl -O ftp://用户名:密码@ip:port/demo/curtain/bbstudy_files/style.css
</code></pre>

<p>15，通过ftp上传</p>

<pre><code>curl -O ftp://用户名:密码@ip:port/demo/curtain/bbstudy_files/style.css
</code></pre>

<p>12，不会显示下载进度信息</p>

<pre><code>curl -T test.sql ftp://用户名:密码@ip:port/demo/curtain/bbstudy_files/
</code></pre>

<p>-a/&mdash;append 上传文件时，附加到目标文件<br>
-A/&mdash;user-agent <string> 设置用户代理发送给服务器<br><br/>
&ndash; anyauth 可以使用“任何”身份验证方法<br>
-b/&mdash;cookie &lt;name=string/file> cookie字符串或文件读取位置<br><br/>
&ndash; basic 使用HTTP基本验证 <br>
-B/&mdash;use-ascii 使用ASCII /文本传输<br><br/>
-c/&mdash;cookie-jar <file> 操作结束后把cookie写入到这个文件中  <br>
-C/&mdash;continue-at <offset> 断点续转<br>
-d/&mdash;data <data> HTTP POST方式传送数据<br>
&mdash;data-ascii <data> 以ascii的方式post数据<br>
&mdash;data-binary <data> 以二进制的方式post数据<br>
&mdash;negotiate 使用HTTP身份验证<br>
&mdash;digest 使用数字身份验证<br>
&mdash;disable-eprt 禁止使用EPRT或LPRT<br>
&mdash;disable-epsv 禁止使用EPSV<br>
-D/&mdash;dump-header <file> 把header信息写入到该文件中<br>
&mdash;egd-file <file> 为随机数据(SSL)设置EGD socket路径<br>
&mdash;tcp-nodelay 使用TCP_NODELAY选项<br>
-e/&mdash;referer 来源网址<br>
-E/&mdash;cert &lt;cert[:passwd]> 客户端证书文件和密码 (SSL)<br>
&mdash;cert-type <type> 证书文件类型 (DER/PEM/ENG) (SSL)<br>
&mdash;key <key> 私钥文件名 (SSL)<br>
&mdash;key-type <type> 私钥文件类型 (DER/PEM/ENG) (SSL)<br>
&mdash;pass <pass> 私钥密码 (SSL)<br>
&mdash;engine <eng> 加密引擎使用 (SSL). &ldquo;&mdash;engine list&rdquo; for list<br>
&mdash;cacert <file> CA证书 (SSL)<br>
&mdash;capath <directory> CA目录 (made using c_rehash) to verify peer against (SSL)<br>
&mdash;ciphers <list> SSL密码<br>
&mdash;compressed 要求返回是压缩的形势 (using deflate or gzip)<br>
&mdash;connect-timeout <seconds> 设置最大请求时间<br>
&mdash;create-dirs 建立本地目录的目录层次结构<br>
&mdash;crlf 上传是把LF转变成CRLF<br>
-f/&mdash;fail 连接失败时不显示http错误<br>
&mdash;ftp-create-dirs 如果远程目录不存在，创建远程目录<br>
&mdash;ftp-method [multicwd/nocwd/singlecwd] 控制CWD的使用<br>
&mdash;ftp-pasv 使用 PASV/EPSV 代替端口<br>
&mdash;ftp-skip-pasv-ip 使用PASV的时候,忽略该IP地址<br>
&mdash;ftp-ssl 尝试用 SSL/TLS 来进行ftp数据传输<br>
&mdash;ftp-ssl-reqd 要求用 SSL/TLS 来进行ftp数据传输<br>
-F/&mdash;form &lt;name=content> 模拟http表单提交数据<br>
-form-string &lt;name=string> 模拟http表单提交数据<br>
-g/&mdash;globoff 禁用网址序列和范围使用{}和[]<br>
-G/&mdash;get 以get的方式来发送数据<br>
-h/&mdash;help 帮助<br>
-H/&mdash;header <line>自定义头信息传递给服务器<br>
&mdash;ignore-content-length 忽略的HTTP头信息的长度<br>
-i/&mdash;include 输出时包括protocol头信息<br>
-I/&mdash;head 只显示文档信息<br>
从文件中读取-j/&mdash;junk-session-cookies忽略会话Cookie<br>
&ndash; 界面<interface>指定网络接口/地址使用<br>
&ndash; krb4 &lt;级别>启用与指定的安全级别krb4<br>
-j/&mdash;junk-session-cookies 读取文件进忽略session cookie<br>
&mdash;interface <interface> 使用指定网络接口/地址<br>
&mdash;krb4 <level> 使用指定安全级别的krb4<br>
-k/&mdash;insecure 允许不使用证书到SSL站点<br>
-K/&mdash;config 指定的配置文件读取<br>
-l/&mdash;list-only 列出ftp目录下的文件名称<br>
&mdash;limit-rate <rate> 设置传输速度<br>
&mdash;local-port<NUM> 强制使用本地端口号<br>
-m/&mdash;max-time <seconds> 设置最大传输时间<br>
&mdash;max-redirs <num> 设置最大读取的目录数<br>
&mdash;max-filesize <bytes> 设置最大下载的文件总量<br>
-M/&mdash;manual 显示全手动<br>
-n/&mdash;netrc 从netrc文件中读取用户名和密码<br>
&mdash;netrc-optional 使用 .netrc 或者 URL来覆盖-n<br>
&mdash;ntlm 使用 HTTP NTLM 身份验证<br>
-N/&mdash;no-buffer 禁用缓冲输出<br>
-o/&mdash;output 把输出写到该文件中<br>
-O/&mdash;remote-name 把输出写到该文件中，保留远程文件的文件名<br>
-p/&mdash;proxytunnel 使用HTTP代理<br>
&mdash;proxy-anyauth 选择任一代理身份验证方法<br>
&mdash;proxy-basic 在代理上使用基本身份验证<br>
&mdash;proxy-digest 在代理上使用数字身份验证<br>
&mdash;proxy-ntlm 在代理上使用ntlm身份验证<br>
-P/&mdash;ftp-port <address> 使用端口地址，而不是使用PASV<br>
-Q/&mdash;quote <cmd>文件传输前，发送命令到服务器<br>
-r/&mdash;range <range>检索来自HTTP/1.1或FTP服务器字节范围<br>
&mdash;range-file 读取（SSL）的随机文件<br>
-R/&mdash;remote-time 在本地生成文件时，保留远程文件时间<br>
&mdash;retry <num> 传输出现问题时，重试的次数   <br>
&mdash;retry-delay <seconds> 传输出现问题时，设置重试间隔时间 <br><br/>
&mdash;retry-max-time <seconds> 传输出现问题时，设置最大重试时间  <br>
-s/&mdash;silent静音模式。不输出任何东西   <br>
-S/&mdash;show-error 显示错误   <br>
&mdash;socks4 &lt;host[:port]> 用socks4代理给定主机和端口 <br/>
&mdash;socks5 &lt;host[:port]> 用socks5代理给定主机和端口 <br/>
&mdash;stderr <file> <br/>
-t/&mdash;telnet-option &lt;OPT=val> Telnet选项设置 <br/>
&mdash;trace <file> 对指定文件进行debug<br/>
&mdash;trace-ascii <file> Like &mdash;跟踪但没有hex输出 <br/>
&mdash;trace-time 跟踪/详细输出时，添加时间戳 <br/>
-T/&mdash;upload-file <file> 上传文件<br/>
&mdash;url <URL> Spet URL to work with <br/>
-u/&mdash;user &lt;user[:password]>设置服务器的用户和密码<br/>
-U/&mdash;proxy-user &lt;user[:password]>设置代理用户名和密码 <br/>
-v/&mdash;verbose <br/>
-V/&mdash;version 显示版本信息 <br/>
-w/&mdash;write-out [format]什么输出完成后 <br/>
-x/&mdash;proxy &lt;host[:port]>在给定的端口上使用HTTP代理<br/>
-X/&mdash;request <command>指定什么命令<br/>
-y/&mdash;speed-time 放弃限速所要的时间。默认为30 <br/>
-Y/&mdash;speed-limit 停止传输速度的限制，速度时间&#8217;秒<br/>
-z/&mdash;time-cond 传送时间设置 <br/>
-0/&mdash;http1.0 使用HTTP 1.0 <br/>
-1/&mdash;tlsv1 使用TLSv1（SSL）<br/>
-2/&mdash;sslv2 使用SSLv2的（SSL）<br/>
-3/&mdash;sslv3 使用的SSLv3（SSL）<br/>
&mdash;3p-quote like -Q for the source URL for 3rd party transfer<br/>
&mdash;3p-url 使用url，进行第三方传送<br/>
&mdash;3p-user 使用用户名和密码，进行第三方传送<br/>
-4/&mdash;ipv4 使用IP4<br/>
-6/&mdash;ipv6 使用IP6<br/>
&ndash;#/&mdash;progress-bar 用进度条显示当前的传送状态</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IT民工的升迁]]></title>
    <link href="http://www.ilehao.com/blog/2013/03/20/it-feedback/"/>
    <updated>2013-03-20T09:00:00+08:00</updated>
    <id>http://www.ilehao.com/blog/2013/03/20/it-feedback</id>
    <content type="html"><![CDATA[<p>   1、 真正基础雄厚的人应该是可以将一个常用的基础性知识熟记成诵的人。提到一个基本的名词或话题能够将其来龙去脉解释清楚的人。<br/>
   2、 我在简历当中最打动面试官的地方恰恰是我利用课余时间及逃课所写的程序，还有利用背考试题的时间所读的课外书。<br/>
   3、 要想成为优秀的程序员，对于基本算法有深入与精确的理解应该是一项必须的基本技能。<br/>
   4、 Your time is limited，so don’t waste it living in someone else’s life. Don’t be trapped by dogma which is living with the results of other people’s thinking. Don’t let the noise of other’s opinions drown out you own inner voice. And the most important, have the courage to your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary.（乔帮主）<br/>
   5、 学知识要注重对本质的掌握，先保证能够将知识点融入到自己的理解里，然后，如果觉得课后作业太弱智，可以尝试新的思路，别一碰到类似的东西就先把以前的搬出来当做“已完成”。<br/>
   6、 知其然不知其所以然，这是我一贯的问题，NB的公司总是问到我的软肋。<br/>
   7、 加强实践与执行力。不要欠生活，不要欠工作。出来混，总是要还的，你不会的知识，你懒于想通的东西，总是会在一个必要的时候提醒你、惩罚你。将没搞懂、希望做到的东西，写在纸上、贴在面前，认真实践，当你做到的越来越多的时候，你就会越来越自信，你的层次会提高的。相信我，人与人之间的差距很大，原因在于自我控制力有差距。——本书最真诚、我最喜欢的一句话。<br/>
   8、 每个人都会在自己的简历上写会C++，但是真正分析过STL源代码的人并不多，每个人都会声称自己精通各类操作系统，但是真正能说清楚Linux系统启动流程的人也不多。<br/>
   9、 如果一个事情比别人多付出5%的努力，就可能拿到相当于别人200%的回报。<br/>
   10、我衡量每一件事的标准就是：这件事够不够我写到简历上？如果够，能不能成为闪光点？——这句话对我学习工作都很有启示！<br/>
   11、世界上没有孤独的高手，却又一堆没人要的半吊子。<br/>
   12、始终保持着乐观的心态和自信心在求职的过程中是头等重要的。<br/>
   13、疯狂收集电子书自有乐趣，你会沉浸在这种乐趣之中，而忽略真正有用的东西和真正要做的事情。——这句话对我很有警示作用！<br/>
   14、坚持写技术博客，进行有效的自我营销。<br/>
   15、你做什么，而不是你想什么，决定你要成为什么样的人。<br/>
   16、看一个人，只要看他读的书和见的人。——真TM精辟！<br/>
   17、今天很残酷，明天更残酷。但后天很美好，大部分人将死在明天晚上，看不到后天的太阳。（马云）<br/>
   18、如果我不够强，就会被淘汰。<br/>
   19、有问题当场提出来是最搞笑的做法。——步入职场可能会体会到。<br/>
   20、人不能停止思考，思考自己，也思考人生，这才是要紧的，也是永远不会晚的。<br/>
   21、零散与不成系统，是网络知识的特点。这样漫无目的的阅读，容易消耗大量的时间，而且容易令人迷失，往往得不偿失。——告诫自己看书会相对好些。<br/>
   22、通常程序员都是伴随着企业一起成长的。<br/>
   23、凡事有计划，认真执行计划，勤记录，常总结。——自知做到这些非易事，但凡做到这都会有大成就，加油吧！<br/>
   24、在这个世界上生存下来，只能靠自己的拼搏和努力，万万不可把希望寄托在别人的身上。——同感，只有自身强大了，才有家庭、家族的荣光！<br/>
   25、之所以能够非常快速地进步和成长，非常大的一个原因就是坚持自己认定的方向，持之以恒，坚持不懈，并且坚持参与交流，坚持与人分享。<br/>
   26、掌握一门技术不是一蹴而就的事，它需要的是严谨的态度、科学的方法和一个必不可少的积累过程。<br/>
   27、有些事情时该做的，有些事情是不该做的，有些事情时可做可不做的；可做可不做的事情做得越少，获得成功的可能性就越大。——努力所在！<br/>
   28、看过了，听懂了，并不意味着真正的理解，只有亲身实践过，能将知识积累消化后分享给他人，才会让学到的东西真正了然于胸，随时拿起来都可以运用自如。<br/>
   29、看书一定要动脑子，蜻蜓点水地看一遍只能收获阅读时的快乐，但真正要用到书中的内容，需要在阅读的时候将精华部分用心牢记才有所得。<br/>
   30、慢即是快，笨笨地做一遍题是学习的捷径。——提醒自己：欲速则不达！<br/>
   31、一字不漏的敲入一本书的程序成了我推荐别人学习语言的最好方法。<br/>
   32、多看书，看好书，并且一定要做笔记。<br/>
   33、 在我看来，成长路径上有很多的偶然，没人知道在一些关键时候需要什么样的知识储备，所以踏实地多储备一些是好事。以前通过看书、自学，彻底地弄懂的一样知识，会在某个不经意的时候，突然被用到。这时候对当年积累的庆幸和再发现的快乐，就像蓦然回首见到灯火阑珊处的秋水伊人一样，是没法用文字描绘的。——非常赞同！<br/>
   34、一本好书读两次要胜过两本好书各读一次。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[tair]]></title>
    <link href="http://www.ilehao.com/blog/2013/01/31/tair/"/>
    <updated>2013-01-31T15:02:00+08:00</updated>
    <id>http://www.ilehao.com/blog/2013/01/31/tair</id>
    <content type="html"><![CDATA[<h2>什么是tair</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Tair是一个高性能，分布式，可扩展，高可靠的key/value结构存储系统。
Tair提供两种存储方式：
非持久，相当于cache
mdb引擎: 只支持key/value，单机性能7w qps（测试条件：单条记录512字节，响应时间2ms内）
rdb引擎: 不仅支持key/value，还支持list/hashmap/set/sortedset等复杂数据结构。
持久化存储，类似数据库。数据直接存放进硬盘，并且至少会有两份。
kdb引擎：采用了kyoto cabinet做为引擎，性能在2000 qps单台。
ldb引擎：采用了leveldb做为引擎，并且自带cache。服务器采用了ssd，性能在5w qps以上。
Tair现在支持Java和C/C++版本的客户端。</p>

<h2>为什么要用tair</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;高可用：能够提供很高的可用性，在服务器宕机的场景下，系统能提供自动化的failover处理；你大可不必对后端某台集群的机器宕机而提心吊胆；
可扩展：能够提供接近线性的扩展能力，并且能够做到扩容过程中不影响前端服务的使用；因此，应用端接入的是一个海量的存储系统，不用太过担心访问量和容量的增长引起数据存储层架构的变化；
高性能：mdb单机性能7w qps，响应时间在2ms内（测试条件：单条平均记录512字节） ldb 性能在5w qps以上，并自带cache，响应时间在4ms内（测试条件：ssd,单条平均记录4096字节）
高可靠：有专门的维护团队，保证tair稳健的运行，同时提供数据备份。</p>

<h2>tair运用场景</h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;Tair存储包括缓存和持久化两种，各有其适用的场景
Tair缓存使用的场景
数据可以以key/value的形式存储
数据可以接受丢失
访问速度要求很高
单个数据大小不是很大，一般在KB级别
数据更新不频繁
Tair持久化适用的场景
数据可以以key/value的形式存储
数据需要持久化
数据量很大，并且有较大的增长可能性
单个数据大小不是很大，一般在KB级别</p>

<h2>tair结构</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[广告交易平台]]></title>
    <link href="http://www.ilehao.com/blog/2013/01/31/rtb/"/>
    <updated>2013-01-31T14:41:00+08:00</updated>
    <id>http://www.ilehao.com/blog/2013/01/31/rtb</id>
    <content type="html"><![CDATA[<p>先给大家解释下名词</p>

<blockquote><p>RTB: (Real Time Bidding)中文名为实时竞价，是一种利用第三方技术在数以百万计的网站上针对每一个用户展示行为进行评估以及出价的竞价技术</p>

<p>DSP: (Demand Side Platform)是一个跨越不同广告资源平台，具有一定数据基础的,能使用统一的定向投放，数据，优化和报告，透明并自动实时地购买媒介广告的需求方平台</p>

<p>Ad Exchange: 针对每次展示进行实时竞价的推广交换市场，能帮助广告联盟、代理结构和第三方技术提供商通过实时竞价的方式购买众多互联网站点的广告资源。</p>

<p>SSP: (Supply Side Platform)是一个网络流量整合平台，拥有大量的网络流量，提供给广告需求方做广告投放。流量来源复杂，融合各大门户网站，视频网络，游戏网络等。</p></blockquote>

<p>同时给大伙说下淘宝平台RTB</p>

<p>淘宝TANX营销平台包括三块：1.淘宝客。2.直通车。3.钻展</p>

<p>实时竞价（RTB）：最合适的受众在最适合的时间，最适合的媒体上看到最适合他 的广告，实现多方共赢。</p>

<p>RTB构成：1.成熟的供应方平台（SSP）；2.需求方平台（DSP）；3.DMP平台（足量用户数据，数据整合，深入受众分析）</p>

<p>RTB精髓：1.实时竞价；2.智能投放</p>

<p>结构图：</p>

<p><img src="../images/blogImgs/rtb.jpg" alt="Alt text" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何恢复Eclipse中删除的文件]]></title>
    <link href="http://www.ilehao.com/blog/2013/01/30/revert-eclipse-delete-file/"/>
    <updated>2013-01-30T09:03:00+08:00</updated>
    <id>http://www.ilehao.com/blog/2013/01/30/revert-eclipse-delete-file</id>
    <content type="html"><![CDATA[<pre><code>其实很简单：选择工程 -&gt; 右键 -&gt; Restore from Local History
</code></pre>

<p>搞定，简单吧！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[统计cooklog每分钟及每30分钟的数据]]></title>
    <link href="http://www.ilehao.com/blog/2012/12/11/statistics-data/"/>
    <updated>2012-12-11T14:48:00+08:00</updated>
    <id>http://www.ilehao.com/blog/2012/12/11/statistics-data</id>
    <content type="html"><![CDATA[<p>统计Cookie_log_total_1和Cookie_log_total_2两个文件，每分钟访问量及每30分钟的访问量</p>

<p>统计每分钟的数据</p>

<pre><code>cat $1 $2  |awk  '{print substr($5,2,18)}' |awk '{a[$1]++}END{for(i in a)print i,a[i]}' | sort &gt;&gt; Cookie_log_total_1
</code></pre>

<p>统计每30分钟的数据</p>

<pre><code>cat Cookie_log_total_1 |awk -F ":" 'BEGIN{total=0}{total+=$4;if($3&gt;29)a=0;if($3&gt;29)scope="29-59";if($3&lt;=29)a=30;if($3&lt;=29)scope="0-29"}{if(a+$3&gt;=59)print $1,":",$2,":",scope,total;if(a+$3&gt;=59)total=0}' &gt;&gt; Cookie_log_total_30
</code></pre>

<p>补充说明：
Cookie_log_total_1的内容如下，其它的类推：</p>

<pre><code>12/Sep/2012:23:59 
46.72.70.123 - - - [12/Sep/2012:23:59:50 -0700] "GET test 
46.72.70.123 - - - [12/Sep/2012:23:59:59 -0700] "GET test" 200 2131 82269 "http://www.a13/ Sep /2012:00:01 
46.72.70.123 - - - [13/ Sep /2012:00:01:50 -0700] "GET test
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[github blog 搭建手册]]></title>
    <link href="http://www.ilehao.com/blog/2012/11/11/github-blog-config/"/>
    <updated>2012-11-11T21:07:00+08:00</updated>
    <id>http://www.ilehao.com/blog/2012/11/11/github-blog-config</id>
    <content type="html"><![CDATA[<p>很多人都希望拥有一个属于自己的免费blog空间。</p>

<p>之前也会在一些技术论坛写blog，但是总觉得那是不属于自己的网站。</p>

<p>现在github给我们一个机会，可以搭建自己的独立博客。</p>

<p>在github上搭建博客可以利用Jekyll或者Octopress, Octopress是在Jekyll上建立起来的，即使没有网站设计经验的人也能够快速搭建自己的博客。</p>

<p>Jekyll和Octopress都是利用Ruby实现的，因此在搭建自己博客的过程中难免要接触到一些Ruby的东西。当然，这也许可以让你开始对Ruby感兴趣，并深入学习之。</p>

<p>现在来简单介绍下Window下搭建blog实施步骤：</p>

<p>*在www.github.com网站上注册一个帐户，并创建你blog站点的repository [username.github.com].</p>

<p>*下载git，安装完成后就可以在本地使用git了,然后在本机使用git创建SSH Key。</p>

<pre><code>ssh-keygen -C "useremail" -t rsa
</code></pre>

<p>备注: useremail为你注册github用户时的邮箱地址
这时，在系统目录下就会生成一个.ssh文件夹，里面为对应的SSH Key，其中id_rsa.pub是Gighub需要的SSH公钥文件。
将id_ras.pub文件里内容拷贝到Github的Account Settings里的key中。
这样你就可以直接使用Git和Github了.</p>

<p>*安装Ruby环境
** 下载RubyInstaller和DevKit,并安装，然后进行到DevKit目录下，运行以下命令</p>

<pre><code>ruby dk.rb init
ruby dk.rb install
gem install rdiscount --platform=ruby
</code></pre>

<p>安装成功后，就可以使用一些Ruby的小工具了。</p>

<p>*安装OctoPress
通过Git从Github上克隆一份Octopress</p>

<pre><code>git clone git://github.com/imathis/octopress.git octopress
</code></pre>

<p>安装一些依赖的工具</p>

<pre><code>cd octopress
gem install bundler
bundle install
</code></pre>

<p>安装Octopress默认的Theme</p>

<pre><code>rake install
</code></pre>

<p>通过_config.yml来配置博客</p>

<p>创建一个博客 <code>rake new_post["title"]</code>
创建一个博客目录 <code>rake new_page["page"]</code>
预览效果：</p>

<pre><code>rake generate
rake preview
</code></pre>

<p>然后在浏览器中打开<a href="http://localhost:4000%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%95%88%E6%9E%9C%E4%BA%86%E3%80%82">http://localhost:4000%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%95%88%E6%9E%9C%E4%BA%86%E3%80%82</a></p>

<p>*将博客部署到Github上
通过<code>rake setup_github_pages</code>命令，将自己的Blog与你在Github创建的repository关联起来。在过程中根据提示输入username.github.com
然后再通过下面命令来把博客内容部署到Github上</p>

<pre><code>rake deploy
git status ##查看更新状态
git add . ##把当前目录上所有的变更加上
git commit -a -m 'commit'
git push origin source
</code></pre>

<ul>
<li>在浏览器中输入username.github.com就可以看到你的博客内容了</li>
</ul>


<p>** 常见问题
乱码，请设置<code>LC_ALL=zh_CN.UTF-8和LANG=zh_CN.UTF-8</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python 学习笔记一]]></title>
    <link href="http://www.ilehao.com/blog/2012/11/04/python-study-note-1/"/>
    <updated>2012-11-04T22:15:00+08:00</updated>
    <id>http://www.ilehao.com/blog/2012/11/04/python-study-note-1</id>
    <content type="html"><![CDATA[<p>之前很粗的学习了下python，没有什么总结，只是写了几个简单的case。
现在总结下常用的一些命令吧。</p>

<p>pythons的setuptools安装</p>

<pre><code>wget http://pypi.python.org/packages/source/d/distribute/distribute-0.6.30.tar.gz
tar -xzvf ./distribute-0.6.30.tar.gz 
cd distribute-0.6.30/
python3 ./setup.py install
</code></pre>

<p>查看setup的命令：</p>

<pre><code>python setup.py --help-commands
</code></pre>

<p>查看BIF
在IDLE shell中，键入</p>

<pre><code>dir(__builtins__)
</code></pre>

<p>alt+p 上一个命令 alt+n 下一个命令
构建发布
先创建一个setup.py文件</p>

<pre><code>from setuptools import setup
setup(name='',version='',author='')
</code></pre>

<p>然后执行以下命令</p>

<pre><code>python setup.py sdist
python setup.py install
</code></pre>

<p>发布到pypi上</p>

<pre><code>python setup.py register
python setup.py sdist upload
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解Javn 虚拟机 学习笔记一]]></title>
    <link href="http://www.ilehao.com/blog/2012/10/28/jvm-study-note1/"/>
    <updated>2012-10-28T20:01:00+08:00</updated>
    <id>http://www.ilehao.com/blog/2012/10/28/jvm-study-note1</id>
    <content type="html"><![CDATA[<p>运行时数据区包含：方法区(method area)、虚拟机栈(VM Stack)、本地方法栈(Native Method Stack)、堆(Heap)、程序计数器(Program Counter Register)</p>

<p>各种区出现Error的情况：</p>

<h1>虚拟机栈</h1>

<ul>
<li>如果线程请求的栈深度大小虚拟机所允许的深度，将抛出StackOverflowError异常</li>
<li>如果虚拟机栈可以动态扩展(当前大部分的Java虚拟机都可以动态扩展，只不过虚拟机规范中也允许固定长度的虚拟机栈)，当扩展时无法申请到足够的内存时会抛出OouOfMemoryError异常

<h1>本地方法栈</h1></li>
<li>因为有的虚拟机(例如 Sun HotSpot)直接是把本地方法栈和虚拟机栈合二为一，所以与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常

<h1>Java 堆</h1></li>
<li>如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常

<h1>方法区</h1></li>
<li>如果方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常

<h1>运行时常量池(Runtime Constant Pool)</h1></li>
<li>由于运行时常量池也是方法区的一部分，所以也会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常

<h1>直接内存</h1></li>
<li>如果服务器管理员配置虚拟机参数时，只考虑实际内存设置 -Xmx等参数信息，而忽略掉了直接内存，使得各个内存区域的总和大于物理内存限制(包括物理上的和操作系统级的限制)，从而会导致动态扩展时出现OutOfMemoryError异常</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何解析超大XML文件]]></title>
    <link href="http://www.ilehao.com/blog/2012/10/28/parse-big-xml-file/"/>
    <updated>2012-10-28T11:26:00+08:00</updated>
    <id>http://www.ilehao.com/blog/2012/10/28/parse-big-xml-file</id>
    <content type="html"><![CDATA[<p>最近工作中碰到需要解析超大XML的问题（XML文件超过1G），并且在处理中还碰到无法解析的异常(org.xml.sax.SAXParseException: An invalid XML character (Unicode: 0x19) was found in the element content of the document)。
现在把处理方式和代码分享出来。
Java代码</p>

<pre><code>try {  
       SAXReader saxReader = new SAXReader();  
       saxReader.addHandler("/list/XXXX", new ElementHandler() {  
           public void onStart(ElementPath path) {  
                         // do nothing here...  
            }  

            public void onEnd(ElementPath path) {  
         // process a ROW element  
        Element row = path.getCurrent();  
        Document document = row.getDocument();  
        System.out.println(document.asXML());  
        row.detach();  
                    }  
                   });  
        }  

        final File file = new File(getFileName(language, isProduct));  
        saxReader.setErrorHandler(new ErrorHandler() {  
        public void error(SAXParseException e) {  
        System.out.println("file:" + file.getName() + "  ERROR: " + e);  
        }  
        public void fatalError(SAXParseException e) {  
        System.out.println("file:" + file.getName() + "  FATAL: " + e);  
        }  
        public void warning(SAXParseException e) {  
         System.out.println("file:" + file.getName() + "  WARNING: " + e);  
        }  
        });  

        InputStreamReader source = new InputStreamReader(new FileInputStream(file));  
        saxReader.read(source);  
    } catch (DocumentException e) {  
        logger.error("error", e);  
        return;  
    } catch (FileNotFoundException e) {  
        logger.error(" error", e);  
        return;  
}  
</code></pre>

<p>如果XML文件中包含了一些不可见的无效字符，就会导致JDom在解析该文件是抛出异常(An invalid XML character Unicode: 0x19 etc)。我们可以通过一些xml工具来保证，如果在xml文件出现了，也可以通过下面这个方法来过滤。
Java代码</p>

<pre><code>public static String stripNonValidXMLCharacters(String in) {  
    StringBuffer out = new StringBuffer(); // Used to hold the output.  
    char current; // Used to reference the current character.  

    if (in == null || ("".equals(in)))  
    return ""; // vacancy test.  
    for (int i = 0; i &lt; in.length(); i++) {  
    current = in.charAt(i); // NOTE: No IndexOutOfBoundsException caught  
                // here; it should not happen.  
    if ((current == 0x9) || (current == 0xA) || (current == 0xD)  
        || ((current &gt;= 0x20) &amp;&amp; (current &lt;= 0xD7FF))  
        || ((current &gt;= 0xE000) &amp;&amp; (current &lt;= 0xFFFD))  
        || ((current &gt;= 0x10000) &amp;&amp; (current &lt;= 0x10FFFF)))  
        out.append(current);  
    }  
    return out.toString();  
}  
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vim 失效的解决办法]]></title>
    <link href="http://www.ilehao.com/blog/2012/10/28/vim-invalid/"/>
    <updated>2012-10-28T11:25:00+08:00</updated>
    <id>http://www.ilehao.com/blog/2012/10/28/vim-invalid</id>
    <content type="html"><![CDATA[<p>解决办法：</p>

<p>  修改 /etc/vim/vim.tiny , 将</p>

<ol>
<li><p>  set compatible 改成 set nocompatible</p></li>
<li><p>  添加 backspace=2</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[快速获取svn的最初分支版本号]]></title>
    <link href="http://www.ilehao.com/blog/2012/10/28/svn-version/"/>
    <updated>2012-10-28T11:25:00+08:00</updated>
    <id>http://www.ilehao.com/blog/2012/10/28/svn-version</id>
    <content type="html"><![CDATA[<p>在做code review时，我们经常要通过svn去找到分支的最初版本号，然后通过svn di命令进行比较。
这里写了个简单的脚本去获取svn的最初版本号
<code> svn log -v --stop-on-copy | grep -B4 "svn copy" | head -1 | awk '{print substr($1,2)}' </code>
所以如果你想对一个分支进行review时，就相当简单了。
定义一个shell脚本，我们暂定为review吧。</p>

<pre><code>VERSION=`svn log -v --stop-on-copy $1 | grep -B4 "svn copy" | head -1 | awk '{print substr($1,2)}' 
svn di -r ${VERSION}:head $1  
</code></pre>

<p>使用方法：
1、把review脚本放到的bin（建议放在/usr/local/bin）目录下，这样你就可以在任何地方使用了。
2、在review脚本后面加上你的svn分支就可以查看修改记录了。例如： review <a href="http://svn.../branches/20120715_155147_1">http://svn&#8230;/branches/20120715_155147_1</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu 配置Apache2+PHP+MySQL]]></title>
    <link href="http://www.ilehao.com/blog/2012/10/28/ubuntu-apache-php-mysql/"/>
    <updated>2012-10-28T11:24:00+08:00</updated>
    <id>http://www.ilehao.com/blog/2012/10/28/ubuntu-apache-php-mysql</id>
    <content type="html"><![CDATA[<p>1.安装apache2.0
<code>sudo apt-get install apache2  </code></p>

<p>当然你也可以用编译的方式安装apache2
apache：下载地址：<a href="http://httpd.apache.org/download.cgi#apache22">http://httpd.apache.org/download.cgi#apache22</a>
编译前准备:
<code>sudo apt-get install build-essential，</code>
不然会出现 checking for C compiler default output file name&hellip; configure: error: C compiler cannot create executables
sudo apt-get install zlib1g-dev
不然 会出现 checking for zlib location&hellip; not found
checking whether to enable mod_deflate&hellip; configure: error: mod_deflate has been requested but can not be built due to prerequisite failures
然后从官网上下载apache2，然后解压（tar -xzvf）编译 (configure / make / make install)
*.config, make and make install:</p>

<pre><code>sudo ./configure --prefi=/usr/soft/apache2 --enable-rewrite=static --with-mpm=worker --enable-so --enable-proxy --enable-proxy-http --enable-deflate --enable-headers --enable-expires --with-included-apr 
make 
make install 
</code></pre>

<p>安装后在浏览器中打开：
<a href="http://localhost/">http://localhost/</a>
或者<a href="http://127.0.0.1">http://127.0.0.1</a>
如果出现It works!那证明OK了</p>

<p>2.安装PHP</p>

<p>依次在终端打开：</p>

<pre><code>sudo apt-get install php5 //安装PHP5  
sudo apt-get install libapache2-mod-php5 //配置APACHE+PHP  
sudo /etc/init.d/apache2 restart //重启APACHE  
</code></pre>

<p>测试：
打开
 <code>sudo  vi /var/www/testphp.php </code></p>

<p>然后随意输入点东西（我输入的是test）再保存。
然后在浏览器中输入<a href="http://127.0.0.1/testphp.php%E6%88%96%E8%80%85http://localhost/testphp.php">http://127.0.0.1/testphp.php%E6%88%96%E8%80%85http://localhost/testphp.php</a>
如果显示出你输入的东西即为成功</p>

<p>3.安装MYSQL
<code> sudo apt-get install mysql-server </code></p>

<p>安装完成按提示设置root密码</p>

<p>4、让apache、php支持 mysql</p>

<pre><code>sudo apt-get install libapache2-mod-auth-mysql  
sudo apt-get install php5-mysql  
sudo /etc/init.d/apache2 restart  
</code></pre>

<p>至此apache2+php+mysql的环境就完成了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[批量替换文件中的字符串]]></title>
    <link href="http://www.ilehao.com/blog/2012/10/28/batch-quickly-replace-string/"/>
    <updated>2012-10-28T11:24:00+08:00</updated>
    <id>http://www.ilehao.com/blog/2012/10/28/batch-quickly-replace-string</id>
    <content type="html"><![CDATA[<p>批量替换文件中的字符串：
你可以先查询下看你要替换的字符串是否会包含在一些别的词中，避免代替其它的词的意思。
<code>find ./ -name "*.vm" | xargs grep "content" </code></p>

<p>确认这个内容都是你要代替的时候，再执行以下这行命令就可以了
<code>find ./ -name "*.vm" | xargs sed -i "s/content/replacecontent/g" </code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何通过vi快速代替文章的指定字符]]></title>
    <link href="http://www.ilehao.com/blog/2012/10/28/vi-quickly-replace-string/"/>
    <updated>2012-10-28T11:23:00+08:00</updated>
    <id>http://www.ilehao.com/blog/2012/10/28/vi-quickly-replace-string</id>
    <content type="html"><![CDATA[<ol>
<li><p>基本的替换
:s/vivian/sky/ 替换当前行第一个 vivian 为 sky
:s/vivian/sky/g 替换当前行所有 vivian 为 sky
:n,$s/vivian/sky/ 替换第 n 行开始到最后一行中每一行的第一个 vivian 为 sky
:n,$s/vivian/sky/g 替换第 n 行开始到最后一行中每一行所有 vivian 为 sky
（n 为数字，若 n 为 .，表示从当前行开始到最后一行）
:%s/vivian/sky/（等同于 :g/vivian/s//sky/） 替换每一行的第一个 vivian 为 sky
:%s/vivian/sky/g（等同于 :g/vivian/s//sky/g） 替换每一行中所有 vivian 为 sky</p></li>
<li><p>可以使用 # 作为分隔符，此时中间出现的 / 不会作为分隔符
:s#vivian/#sky/# 替换当前行第一个 vivian/ 为 sky/
:%s+/oradata/apras/+/user01/apras1+ （使用+ 来 替换 / ）： /oradata/apras/替换成/user01/apras1/</p></li>
<li><p>删除文本中的<sup>M</sup>
问题描述：对于换行，window下用回车换行（0A0D）来表示，linux下是回车（0A）来表示。这样，将window上的文件拷到unix上用时，总会有个<sup>M</sup>，请写个用在unix下的过滤windows文件的换行符（0D）的shell或c程序。</p></li>
</ol>


<p>使用命令：cat filename1 | tr -d “<sup>V</sup><sup>M</sup>” > newfile;
使用命令：sed -e “s/^V<sup>M</sup>//” filename > outputfilename</p>

<p>需要注意的是在1、2两种方法中，<sup>V</sup>和<sup>M</sup>指的是Ctrl+V和Ctrl+M。你必须要手工进行输入，而不是粘贴。</p>

<p>在vi中处理：首先使用vi打开文件，然后按ESC键，接着输入命令：
:%s/^V<sup>M</sup>//
:%s/^M$//g</p>

<p>如果上述方法无用，则正确的解决办法是：
tr -d “\r” &lt; src >dest
tr -d “\015〃 dest
strings A>B</p>

<ol>
<li>其它用法
利用 :s 命令可以实现字符串的替换。具体的用法包括：
:s/str1/str2/ 用字符串 str2 替换行中首次出现的字符串 str1
:s/str1/str2/g 用字符串 str2 替换行中所有出现的字符串 str1
:.,$ s/str1/str2/g 用字符串 str2 替换正文当前行到末尾所有出现的字符串 str1
:1,$ s/str1/str2/g 用字符串 str2 替换正文中所有出现的字符串 str1
:g/str1/s//str2/g 功能同上</li>
</ol>


<p>从上述替换命令可以看到：g 放在命令末尾，表示对搜索字符串的每次出现进行替换；不加 g，表示只对搜索字符串的首次出现进行替换；g 放在命令开头，表示对正文中所有包含搜索字符串的行进行替换操作。</p>

<p>代替前面几个字符：%s/^&hellip;//g 一个小点代表一个字符
代替后面几个字符：%s/&hellip;$//g 一个小点代表一个字符</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java代码编写的30条建议]]></title>
    <link href="http://www.ilehao.com/blog/2012/10/28/java-code-30-items-suggest/"/>
    <updated>2012-10-28T11:22:00+08:00</updated>
    <id>http://www.ilehao.com/blog/2012/10/28/java-code-30-items-suggest</id>
    <content type="html"><![CDATA[<p>(1) 类名首字母应该大写。字段、方法以及对象（句柄）的首字母应小写。对于所有标识符，其中包含的所有单词都应紧靠在一起，而且大写中间单词的首字母。例如：
ThisIsAClassNamethisIsMethodOrFieldName
若在定义中出现了常数初始化字符，则大写static final基本类型标识符中的所有字母。这样便可标志出它们属于编译期的常数。
Java包（Package）属于一种特殊情况：它们全都是小写字母，即便中间的单词亦是如此。对于域名扩展名称，如com，org，net或者edu等，全部都应小写（这也是Java 1.1和Java 1.2的区别之一）。</p>

<p>(2) 为了常规用途而创建一个类时，请采取&#8221;经典形式&#8221;，并包含对下述元素的定义：
equals()<br/>
hashCode()<br/>
toString()<br/>
clone()（implement Cloneable）<br/>
implement Serializable</p>

<p>(3) 对于自己创建的每一个类，都考虑置入一个main()，其中包含了用于测试那个类的代码。为使用一个项目中的类，我们没必要删除测试代码。若进行了任何形式的改动，可方便地返回测试。这些代码也可作为如何使用类的一个示例使用。</p>

<p>(4) 应将方法设计成简要的、功能性单元，用它描述和实现一个不连续的类接口部分。理想情况下，方法应简明扼要。若长度很大，可考虑通过某种方式将其分割成较短的几个方法。这样做也便于类内代码的重复使用（有些时候，方法必须非常大，但它们仍应只做同样的一件事情）。</p>

<p>(5) 设计一个类时，请设身处地为客户程序员考虑一下（类的使用方法应该是非常明确的）。然后，再设身处地为管理代码的人考虑一下（预计有可能进行哪些形式的修改，想想用什么方法可把它们变得更简单）。</p>

<p>(6) 使类尽可能短小精悍，而且只解决一个特定的问题。下面是对类设计的一些建议： <br/>
◆  一个复杂的开关语句：考虑采用&#8221;多形&#8221;机制<br/>
◆ 数量众多的方法涉及到类型差别极大的操作：考虑用几个类来分别实现 <br/>
◆ 许多成员变量在特征上有很大的差别：考虑使用几个类</p>

<p>(7) 让一切东西都尽可能地&#8221;私有&#8221;&mdash;private。可使库的某一部分&#8221;公共化&#8221;（一个方法、类或者一个字段等等），就永远不能把它拿出。若强行拿出，就可能破坏其他人现有的代码，使他们不得不重新编写和设计。若只公布自己必须公布的，就可放心大胆地改变其他任何东西。在多线程环境中，隐私是特别重要的一个因素&mdash;只有private字段才能在非同步使用的情况下受到保护。</p>

<p>(8) 谨惕&#8221;巨大对象综合症&#8221;。对一些习惯于顺序编程思维、且初涉OOP领域的新手，往往喜欢先写一个顺序执行的程序，再把它嵌入一个或两个巨大的对象里。根据编程原理，对象表达的应该是应用程序的概念，而非应用程序本身。</p>

<p>(9) 若不得已进行一些不太雅观的编程，至少应该把那些代码置于一个类的内部。</p>

<p>(10) 任何时候只要发现类与类之间结合得非常紧密，就需要考虑是否采用内部类，从而改善编码及维护工作（参见第14章14.1.2小节的&#8221;用内部类改进代码&#8221;）。</p>

<p>(11) 尽可能细致地加上注释，并用javadoc注释文档语法生成自己的程序文档。</p>

<p>(12) 避免使用&#8221;魔术数字&#8221;，这些数字很难与代码很好地配合。如以后需要修改它，无疑会成为一场噩梦，因为根本不知道&#8221;100&#8221;到底是指&#8221;数组大小&#8221;还是&#8221;其他全然不同的东西&#8221;。所以，我们应创建一个常数，并为其使用具有说服力的描述性名称，并在整个程序中都采用常数标识符。这样可使程序更易理解以及更易维护。</p>

<p>(13) 涉及构建器和异常的时候，通常希望重新丢弃在构建器中捕获的任何异常&mdash;如果它造成了那个对象的创建失败。这样一来，调用者就不会以为那个对象已正确地创建，从而盲目地继续。</p>

<p>(14) 当客户程序员用完对象以后，若你的类要求进行任何清除工作，可考虑将清除代码置于一个良好定义的方法里，采用类似于cleanup()这样的名字，明确表明自己的用途。除此以外，可在类内放置一个boolean（布尔）标记，指出对象是否已被清除。在类的finalize()方法里，请确定对象已被清除，并已丢弃了从RuntimeException继承的一个类（如果还没有的话），从而指出一个编程错误。在采取象这样的方案之前，请确定finalize()能够在自己的系统中工作（可能需要调用System.runFinalizersOnExit(true)，从而确保这一行为）。</p>

<p>(15) 在一个特定的作用域内，若一个对象必须清除（非由垃圾收集机制处理），请采用下述方法：初始化对象；若成功，则立即进入一个含有finally从句的try块，开始清除工作。</p>

<p>(16) 若在初始化过程中需要覆盖（取消）finalize()，请记住调用super.finalize()（若Object属于我们的直接超类，则无此必要）。在对finalize()进行覆盖的过程中，对super.finalize()的调用应属于最后一个行动，而不应是第一个行动，这样可确保在需要基础类组件的时候它们依然有效。</p>

<p>(17) 创建大小固定的对象集合时，请将它们传输至一个数组（若准备从一个方法里返回这个集合，更应如此操作）。这样一来，我们就可享受到数组在编译期进行类型检查的好处。此外，为使用它们，数组的接收者也许并不需要将对象&#8221;造型&#8221;到数组里。</p>

<p>(18) 尽量使用interfaces，不要使用abstract类。若已知某样东西准备成为一个基础类，那么第一个选择应是将其变成一个interface（接口）。只有在不得不使用方法定义或者成员变量的时候，才需要将其变成一个abstract（抽象）类。接口主要描述了客户希望做什么事情，而一个类则致力于（或允许）具体的实施细节。</p>

<p>(19) 在构建器内部，只进行那些将对象设为正确状态所需的工作。尽可能地避免调用其他方法，因为那些方法可能被其他人覆盖或取消，从而在构建过程中产生不可预知的结果（参见第7章的详细说明）。</p>

<p>(20) 对象不应只是简单地容纳一些数据；它们的行为也应得到良好的定义。</p>

<p>(21) 在现成类的基础上创建新类时，请首先选择&#8221;新建&#8221;或&#8221;创作&#8221;。只有自己的设计要求必须继承时，才应考虑这方面的问题。若在本来允许新建的场合使用了继承，则整个设计会变得没有必要地复杂。</p>

<p>(22) 用继承及方法覆盖来表示行为间的差异，而用字段表示状态间的区别。一个非常极端的例子是通过对不同类的继承来表示颜色，这是绝对应该避免的：应直接使用一个&#8221;颜色&#8221;字段。</p>

<p>(23) 为避免编程时遇到麻烦，请保证在自己类路径指到的任何地方，每个名字都仅对应一个类。否则，编译器可能先找到同名的另一个类，并报告出错消息。若怀疑自己碰到了类路径问题，请试试在类路径的每一个起点，搜索一下同名的.class文件。</p>

<p>(24) 在Java 1.1 AWT中使用事件&#8221;适配器&#8221;时，特别容易碰到一个陷阱。若覆盖了某个适配器方法，同时拼写方法没有特别讲究，最后的结果就是新添加一个方法，而不是覆盖现成方法。然而，由于这样做是完全合法的，所以不会从编译器或运行期系统获得任何出错提示&mdash;只不过代码的工作就变得不正常了。</p>

<p>(25) 用合理的设计方案消除&#8221;伪功能&#8221;。也就是说，假若只需要创建类的一个对象，就不要提前限制自己使用应用程序，并加上一条&#8221;只生成其中一个&#8221;注释。请考虑将其封装成一个&#8221;独生子&#8221;的形式。若在主程序里有大量散乱的代码，用于创建自己的对象，请考虑采纳一种创造性的方案，将些代码封装起来。</p>

<p>(26) 警惕&#8221;分析瘫痪&#8221;。请记住，无论如何都要提前了解整个项目的状况，再去考察其中的细节。由于把握了全局，可快速认识自己未知的一些因素，防止在考察细节的时候陷入&#8221;死逻辑&#8221;中。</p>

<p>(27) 警惕&#8221;过早优化&#8221;。首先让它运行起来，再考虑变得更快&mdash;但只有在自己必须这样做、而且经证实在某部分代码中的确存在一个性能瓶颈的时候，才应进行优化。除非用专门的工具分析瓶颈，否则很有可能是在浪费自己的时间。性能提升的隐含代价是自己的代码变得难于理解，而且难于维护。</p>

<p>(28) 请记住，阅读代码的时间比写代码的时间多得多。思路清晰的设计可获得易于理解的程序，但注释、细致的解释以及一些示例往往具有不可估量的价值。无论对你自己，还是对后来的人，它们都是相当重要的。如对此仍有怀疑，那么请试想自己试图从联机Java文档里找出有用信息时碰到的挫折，这样或许能将你说服。</p>

<p>(29) 如认为自己已进行了良好的分析、设计或者实施，那么请稍微更换一下思维角度。试试邀请一些外来人士&mdash;并不一定是专家，但可以是来自本公司其他部门的人。请他们用完全新鲜的眼光考察你的工作，看看是否能找出你一度熟视无睹的问题。采取这种方式，往往能在最适合修改的阶段找出一些关键性的问题，避免产品发行后再解决问题而造成的金钱及精力方面的损失。</p>

<p>(30) 良好的设计能带来最大的回报。简言之，对于一个特定的问题，通常会花较长的时间才能找到一种最恰当的解决方案。但一旦找到了正确的方法，以后的工作就轻松多了，再也不用经历数小时、数天或者数月的痛苦挣扎。我们的努力工作会带来最大的回报（甚至无可估量）。而且由于自己倾注了大量心血，最终获得一个出色的设计方案，成功的快感也是令人心动的。坚持抵制草草完工的诱惑&mdash;那样做往往得不偿失。</p>
]]></content>
  </entry>
  
</feed>
