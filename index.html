
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>乐皓博客</title>
  <meta name="author" content="乐皓">

  
  <meta name="description" content="线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种： 1、协同式(Cooperative Threads-Scheduling) 线程调度 2、抢占式(Preemptive Threads-Scheduling) 线程调度 抢先式调度又分为：时间片方式和独占方式。在时间片方式下， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.ilehao.com/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="乐皓博客" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">乐皓博客</a></h1>
  
    <h2>爱乐，爱皓，爱乐皓.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.ilehao.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">博客</a></li>
  <li><a href="/blog/archives">文章列表</a></li>
  <li><a href="/aboutme">关于Me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/03/27/thread-wait-sleep/">Thread.sleep()与Object.wait()的区别</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-03-27T10:19:00+08:00" pubdate data-updated="true">Mar 27<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/03/27/thread-wait-sleep/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种：</h4>

<p>1、协同式(Cooperative Threads-Scheduling) 线程调度 <br/>
2、抢占式(Preemptive Threads-Scheduling) 线程调度</p>

<p>抢先式调度又分为：时间片方式和独占方式。在时间片方式下，当前活动线程执行完当前时间片后，如果有其他处于就绪状态的相同优先级的线程，系统会将执行权交给其他就绪态的同优先级线程；当前活动线程转入等待执行队列，等待下一个时间片的调度。</p>

<p>在独占方式下，当前活动线程一旦获得执行权，将一直执行下去，直到执行完毕或由于某种原因主动放弃CPU，或者是有一高优先级的线程处于就绪状态。</p>

<h2>Thread.sleep()和　Object.wait()区别</h2>

<h6>共同点：</h6>

<p>1、保持多线程同步的一种方式，可以让程序的调用处阻塞指定的毫秒数，并返回。</p>

<p>2、wait()和sleep()都可以通过interrupt()方法，打断线程的暂停状态 ，从而使线程立刻抛出InterruptedException。 例如线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep /join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。</p>

<p>需要注意的是，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出InterruptedException 。</p>

<h6>不同点：</h6>

<p>1、sleep是Thread类的方法，是线程用来 控制自身流程的，比如有一个要报时的线程，每一秒中打印出一个时间，那么我就需要在print方法前面加上一个sleep让自己每隔一秒执行一次。就像个闹钟一样。
wait是Object类的方法，用来线程间的通信，这个方法会使当前拥有该对象锁的进程等待知道其他线程调用notify方法时再醒来，不过你也可以给他指定一个时间，自动醒来。这个方法主要是用走不同线程之间的调度的。</p>

<p>2、调用Thread.sleep()方法不会释放锁，而调用Object.wait()方法是会释放当前锁。
JDK 7 中的解释：</p>

<blockquote><p>public static void sleep(long millis) throws InterruptedException
Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds, subject to the precision and accuracy of system timers and schedulers.The thread does not lose ownership of any monitors.</p>

<p>public final void wait() throws InterruptedException
Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. In other words, this method behaves exactly as if it simply performs the call wait(0).The current thread must own this object&rsquo;s monitor. The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object&rsquo;s monitor to wake up either through a call to the notify method the notifyAll method. The thread then waits until it can re-obtain ownership of the monitor and resumes execution.“</p></blockquote>

<p>3、由于wait函数的特殊意义，应该放在同步语句块中的，这样才有意义。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/03/21/string-intern/">我对String及String.intern()的理解</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-03-21T14:18:00+08:00" pubdate data-updated="true">Mar 21<span>st</span>, 2014</time>
        
         | <a href="/blog/2014/03/21/string-intern/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>先来聊聊String,对于做java开发的我们,string应该是相当熟悉的</h4>

<p>1、String不属于8种基本数据类型，String是一个对象,所以String的默认值也是null。但它又有其它对象没有的一些特性，比如它是final类等等。 <br/>
2、new String()和new String(&ldquo;&rdquo;)都是申明一个新的空字符串，是空串不是null。  <br/>
3、String str=”abc”,String str=new String(&ldquo;abc&rdquo;)的区别。</p>

<blockquote><p>Java把内存划分成两种：一种是栈内存，一种是堆内存。   <br/>
在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。  <br/>
当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。 <br/>
堆内存用来存放由new创建的对象和数组。 <br/>
在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。 <br/>
在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。  <br/>
引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。   <br/>
具体的说：
栈与堆都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。
Java的堆是一个运行时数据区,类的(对象从中分配空间。这些对象通过new、newarray、anewarray和multianewarray等指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。
栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量（,int, short, long, byte, float, double, boolean, char）和对象句柄。
栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：</p>

<pre><code>int a = 3; 
int b = 3； 
</code></pre>

<p>编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3；在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。这时，如果再令a=4；那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。
String是一个特殊的包装类数据。可以用：</p>

<pre><code>String str = new String("abc"); 
String str = "abc"; 
</code></pre>

<p>两种的形式来创建，第一种是用new()来新建对象的，它会在存放于堆中。每调用一次就会创建一个新的对象。
而第二种是先在栈中创建一个对String类的对象引用变量str，然后查找栈中有没有存放&#8221;abc&#8221;，如果没有，则将&#8221;abc&#8221;存放进栈，并令str指向”abc”，如果已经有”abc” 则直接令str指向“abc”。
比较类里面的数值是否相等时，用equals()方法；当测试两个包装类的引用是否指向同一个对象时，用==，下面用例子说明上面的理论。</p>

<pre><code>String str1 = "abc"; 
String str2 = "abc"; 
System.out.println(str1==str2); //true 
</code></pre>

<p>可以看出str1和str2是指向同一个对象的。</p>

<pre><code>String str1 =new String ("abc"); 
String str2 =new String ("abc"); 
System.out.println(str1==str2); // false 
</code></pre>

<p>用new的方式是生成不同的对象。每一次生成一个。
因此用第二种方式创建多个”abc”字符串,在内存中其实只存在一个对象而已。 这种写法有利与节省内存空间. 同时它可以在一定程度上提高程序的运行速度，因为JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象。而对于String str = new String(&ldquo;abc&rdquo;)；的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。
另一方面, 要注意: 我们在使用诸如String str = &ldquo;abc&#8221;；的格式定义类时，总是想当然地认为，创建了String类的对象str。担心陷阱！对象可能并没有被创建！而可能只是指向一个先前已经创建的对象。只有通过new()方法才能保证每次都创建一个新的对象。由于String类的immutable性质，当String变量需要经常变换其值时，应该考虑使用StringBuffer类，以提高程序效率。</p></blockquote>

<h2>现在我们再说说String.intern(), JDK 7里String.intern生成的String不再是在perm gen分配，而是在Java Heap中分配</h2>

<blockquote><p>In JDK 7, interned strings are no longer allocated in the permanent generation of the Java heap, but are instead allocated in the main part of the Java heap (known as the young and old generations), along with the other objects created by the application. This change will result in more data residing in the main Java heap, and less data in the permanent generation, and thus may require heap sizes to be adjusted. Most applications will see only relatively small differences in heap usage due to this change, but larger applications that load many classes or make heavy use of the String.intern() method will see more sign</p></blockquote>

<h2>先对这个方法做个解释</h2>

<blockquote><p>public String intern()
返回字符串对象的规范化表示形式。
一个初始时为空的字符串池，它由类 String 私有地维护。
当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（该对象由 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并且返回此 String 对象的引用。
它遵循对于任何两个字符串 s 和 t，当且仅当 s.equals(t) 为 true 时，s.intern() == t.intern() 才为 true。
所有字面值字符串和字符串赋值常量表达式都是内部的。
返回：
一个字符串，内容与此字符串相同，但它保证来自字符串池中。</p></blockquote>

<h2>下面我们看一个范例：</h2>

<pre><code>String str1 = "abc";
String str2 = "def";
String str3 = "abcdef";
String str4 = str1 + str2;
String str5 = new String("abcdef");
System.out.println(str5.equals(str3)); //true
System.out.println(str5 == str3); //false
System.out.println(str5.intern() == str3); //true
System.out.println(str5.intern() == str4); //jdk6 false jdk7 true
</code></pre>

<p>看到上面的结果大家肯定有疑惑，下面我为大家一一解答： <br/>
1、str5.equals(str3)这个结果为true，不用太多的解释，因为字符串的值的内容相同 <br/>
2、str5 == str3对比的是引用的地址是否相同，由于str5采用new String方式定义的，所以地址引用一定不相等。所以结果为false。<br/>
3、当str5调用intern的时候，会检查字符串池中是否含有该字符串。由于之前定义的str3已经进入字符串池中，所以会得到相同的引用。<br/>
4、原因是因为JDK 6中执行String.intern()时需要将此字符串的实例cp到perm并生成一个新的String对象，因此上面的s5和s4的对象地址是不同的，而在JDK 7中，执行String.intern()时，则只是在String Pool中记录此字符内容对应的字符串实例。</p>

<p>尽管在比较字符串时，一般都不会用 == 去比较，但还是要知道String.intern()的这个变化。String.intern()放进的String Pool是一个固定大小的Hashtable，默认值是1009，如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降（因为要一个一个找）。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/03/19/linux-apache-grep-log/">linux下grep分析APACHE 服务器日志 命令集合</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-03-19T14:54:00+08:00" pubdate data-updated="true">Mar 19<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/03/19/linux-apache-grep-log/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>分析日志</h2>

<p>1.分析日志文件下 2014-03-17 访问页面最高 的前20个 URL 并排序</p>

<pre><code>cat cookie_log |grep '17/Mar/2014'| awk '{print $12}'|sort|uniq -c|sort -nr|head -20   
</code></pre>

<p>2.获取访问最高的10个IP地址  同时也可以按时间来查询</p>

<pre><code>cat cookie_log|awk '{print $1}'|sort|uniq -c|sort -nr|head -10    
</code></pre>

<p>3.列出传输最大的几个exe文件（分析下载站的时候常用）</p>

<pre><code>cat cookie_log |awk '($7~/\.exe/){print $10 " " $1 " " $4 " " $7}'|sort -nr|head -20    
</code></pre>

<p>4.列出输出大于200000byte(约200kb)的exe文件以及对应文件发生次数</p>

<pre><code>cat cookie_log |awk '($10 &gt; 200000 &amp;&amp; $7~/\.exe/){print $7}'|sort -n|uniq -c|sort -nr|head -100    
</code></pre>

<p>5.如果日志最后一列记录的是页面文件传输时间，则有列出到客户端最耗时的页面</p>

<pre><code>cat cookie_log |awk '($7~/\.php/){print $NF " " $1 " " $4 " " $7}'|sort -nr|head -100    
</code></pre>

<p>6.列出最最耗时的页面(超过60秒的)的以及对应页面发生次数</p>

<pre><code>cat cookie_log |awk '($NF &gt; 60 &amp;&amp; $7~/\.html/){print $7}'|sort -n|uniq -c|sort -nr|head -100   
</code></pre>

<p>7.列出传输时间超过 30 秒的文件</p>

<pre><code>cat cookie_log |awk '($NF &gt; 30){print $7}'|sort -n|uniq -c|sort -nr|head -20   
</code></pre>

<p>8.统计网站流量（G)</p>

<pre><code>cat cookie_log |awk '{sum+=$10} END {print sum/1024/1024/1024}'   
</code></pre>

<p>9.统计404的连接</p>

<pre><code>awk '($10 ~/404/)' cookie_log | awk '{print $10,$13}' | sort     
</code></pre>

<p>10.统计http status.</p>

<pre><code>cat cookie_log |awk '{counts[$(10)]+=1}; END {for(code in counts) print code, counts[code]}'  
cat cookie_log |awk '{print $10}'|sort|uniq -c|sort -rn   
</code></pre>

<p>11.每秒并发：</p>

<pre><code>awk '{if($10~/200|30|404/)COUNT[$5]++}END{for( a in COUNT) print a,COUNT[a]}'|sort -k 2 -nr|head -n10    
</code></pre>

<p>12.带宽统计</p>

<pre><code>cat apache.log |awk '{if($7~/GET/) count++}END{print "client_request="count}'   
cat apache.log |awk '{BYTE+=$11}END{print "client_kbyte_out="BYTE/1024"KB"}'    
</code></pre>

<p>13.找出某天访问次数最多的10个IP</p>

<pre><code>cat cookie_log | grep "17/Mar/2014" |awk '{print $3}'|sort |uniq -c|sort -nr|head   
</code></pre>

<p>14.当天ip连接数最高的ip都在干些什么:</p>

<pre><code>cat cookie_log | grep "10.0.21.17" | awk '{print $8}' | sort | uniq -c | sort -nr | head -n 10    
</code></pre>

<p>15.找出访问次数最多的几个分钟</p>

<pre><code>awk '{print $1}' cookie_log | grep "20/Mar/2011" |cut -c 14-18|sort|uniq -c|sort -nr|head   
</code></pre>

<h2>连接状态</h2>

<p>1.查看tcp连接状态:</p>

<pre><code>netstat -nat |awk '{print $6}'|sort|uniq -c|sort -rn
netstat -n | awk '/^tcp/ {++S[$NF]};END {for(a in S) print a, S[a]}'
netstat -n | awk '/^tcp/ {++state[$NF]}; END {for(key in state) print key,"\t",state[key]}'
netstat -n | awk '/^tcp/ {++arr[$NF]};END {for(k in arr) print k,"\t",arr[k]}'
netstat -n |awk '/^tcp/ {print $NF}'|sort|uniq -c|sort -rn
netstat -ant | awk '{print $NF}' | grep -v '[a-z]' | sort | uniq -c
netstat -ant|awk '/ip:80/{split($5,ip,":");++S[ip[1]]}END{for (a in S) print S[a],a}' |sort -n
netstat -ant|awk '/:80/{split($5,ip,":");++S[ip[1]]}END{for (a in S) print S[a],a}' |sort -rn|head -n 10
awk 'BEGIN{printf ("http_code\tcount_num\n")}{COUNT[$10]++}END{for (a in COUNT) printf a"\t\t"COUNT[a]"\n"}'    
</code></pre>

<p>2.查找请求数请20个IP（常用于查找攻来源）：</p>

<pre><code>netstat -anlp|grep 80|grep tcp|awk '{print $5}'|awk -F: '{print $1}'|sort|uniq -c|sort -nr|head -n20
netstat -ant |awk '/:80/{split($5,ip,":");++A[ip[1]]}END{for(i in A) print A[i],i}' |sort -rn|head -n20    
</code></pre>

<p>3.用tcpdump嗅探80端口的访问看看谁最高</p>

<pre><code>tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F"." '{print $1"."$2"."$3"."$4}' | sort | uniq -c | sort -nr |head -20    
</code></pre>

<p>4.查找较多time_wait连接</p>

<pre><code>netstat -n|grep TIME_WAIT|awk '{print $5}'|sort|uniq -c|sort -rn|head -n20    
</code></pre>

<p>5.找查较多的SYN连接</p>

<pre><code>netstat -an | grep SYN | awk '{print $5}' | awk -F: '{print $1}' | sort | uniq -c | sort -nr | more   
</code></pre>

<p>6.根据端口列进程</p>

<pre><code>netstat -ntlp | grep 80 | awk '{print $7}' | cut -d/ -f1   
</code></pre>

<h2>附 sort、uniq命令参数说明</h2>

<p>sort命令:</p>

<pre><code>表示逐行对指定文件中的所有行进行排序，并将结果显示在标准输出上。如果不指定文件或者使用“一”
表示文件，则排序内容来自标准输入。排序比较是依据从输入文件的每一行中提取的一个或多个排序关键字进
行的。排序关键字定义了用来排序的最小的字符序列。在默认情况下，排序关键字的顺序由系统使用的字符集
决定。
选项：
-m 对己经排好序的文件统一进行合并，但不做排序。
-c 检查给定的文件是否己排好序，若没有，则显示出错消息，不做排序。
-u与-c 选项一起用，严格地按顺序检查；否则，对排序后的重复行只输出第一行。
-o 文件名 将排序输出放到该文件名所指定的文件中。如果该文件不存在，则创建一个新文件。
改变排序规则的选项主要有：
-d 按字典顺序排序，比较时仅考虑空白符和字母数字符。
-f 忽略字母的大小写。
-i 忽略非打印字符。
-M 规定月份的比较次序是（未知）&lt;”JAN”&lt;”FEB”&lt;…&lt;”DEC”。 
-r 按逆序排序。默认排序输出是按升序排序的。
-k n1[,n2] 指定从文本行的第n1字段开始至第n2字段（不包括第n2字段）中间的内容作为排序关键字。如果没有n2，则关键字是从第n1个字段到行尾的所有字段。n1和n2可以是小数形式。如”x.y”，x表示第x字段，y表示第x字段中的第y个字符。字段和字符的文职都是从1开始算起的。
-b 比较关键字时忽略前导的空白符（空格或制表符）。
-t 字符将指定的“字符”作为字段间的分隔符。    
</code></pre>

<p>uniq命令：</p>

<pre><code>[选项] 文件
说明：uniq命令读取输入文件，并比较相邻的行，去掉重复的行一行。该命令加工后的结果写到输出文件中。
输入文件和输出文件必须不同。用“一”表示，则从标准输入上读取。选项：
-c 显示输出时，在每行的行首加上该行在文件中出现的次数。
-d 只显示重复行。
-f --skip-fields=N  忽略比较前N个字段。
-s --skip-chars=N 忽略比较前N个字段。
-u 只显示文件中不重复的行。
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/03/18/special-character/">特殊字符的含义</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-03-18T14:46:00+08:00" pubdate data-updated="true">Mar 18<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/03/18/special-character/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>特殊字符的含义
URL编码</p>

<pre><code>#   用来标志特定的文档位置   %23
%  对特殊字符进行编码        %25
&amp;   分隔不同的变量值对       %26
+    在变量值中表示空格      %2B
/     表示目录路径           %2F
\     表示目录路径           %5C
=    用来连接键和值          %3D
?     表示查询字符串的开始   %3F
空格  空格                   %20
.       句号                 %2E
:       冒号                 %3A
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/03/04/idp/">2014个人发展计划(IDP)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-03-04T10:24:00+08:00" pubdate data-updated="true">Mar 4<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/03/04/idp/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>劣势</h2>

<blockquote><p>JVM底层相关知识了解还不够深入 <br/>
业务面不够宽，需要拓宽自己的业务 <br/>
技术架构能力需进一步加强</p></blockquote>

<h2>优势</h2>

<blockquote><p>熟悉开发流程 <br/>
身边有许多大牛</p></blockquote>

<h2>能力发展规划</h2>

<blockquote><p>深入学习asm,btrace <br/>
在seo方面有自己的建树 <br/>
学习分布式zookeeper<br/>
加强与其它团队的技术和业务交流</p></blockquote>

<h2>执行计划</h2>

<blockquote><p><table border="1">
<thead>
<tr>
<th>任务</th>
<th align="left">计划</th>
<th align="center">action</th>
</tr>
</thead>
<tbody>
<tr>
<td>深入学习asm,btace</td>
<td align="left">3月-4月</td>
<td align="center"> 深入源代码，了解其原理，能总结出自己的见解和优化方案 </td>
</tr>
<tr>
<td>学习zookeeper</td>
<td align="left">4月-9月</td>
<td align="center"> </td>
</tr>
<tr>
<td>读完SEO实战密码</td>
<td align="left">4月-9月</td>
<td align="center">   </td>
</tr>
</tbody>
</table></p></blockquote>

<p><font color="red" size="5">以上请大家监督</font></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/21/git-blog-r-and-q/">Git Blog R&amp;Q</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-21T14:38:00+08:00" pubdate data-updated="true">Feb 21<span>st</span>, 2014</time>
        
         | <a href="/blog/2014/02/21/git-blog-r-and-q/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>一、rake gen_deploy时提示版本不对</p>

<pre><code>To https://github.com/username/username.github.io
! [rejected] master -&amp;gt; master (non-fast-forward)
error: failed to push some refs to 'https://github.com/username/username.github.io'
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Merge the remote changes (e.g. 'git pull')
hint: before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
</code></pre>

<p>按以下步骤操作:</p>

<pre><code>git clone https://github.com/username/username.github.io.git
git checkout source

mkdir _deploy
cd _deploy
git init
git remote add -t master -f origin https://github.com/username/username.github.io.git
</code></pre>

<p>现在再试下 <code>rake gen_deploy</code></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/20/zhaopin/">Alibaba招聘</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-20T10:07:00+08:00" pubdate data-updated="true">Feb 20<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/02/20/zhaopin/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><pre><code>alibaba招聘目标层级是P6及以上高级java开发工程师，具体的要求见下：
1.JAVA基础扎实，熟悉io、多线程、集合等基础框架，熟悉分布式、缓存、消息、搜索等机制；
2.两年以上使用java进行web开发的经验，熟练使用spring 、MVC等框架，熟悉Linux下的常用命令，熟悉MySQL；
3.熟悉常用设计模式，有大型分布式、高并发、高负载、高可用性系统设计开发经验；
4.熟悉或精通脚本语言：如python\shell\php等
5.具有一定的项目规划和决策能力，善于捕捉业务需求、架构设计中存在的问题，并给出有效的解决措施和方法；
6.具有良好的抽象设计能力，思路清晰，善于思考，能独立分析和解决问题,责任心强，具备良好的团队合作精神和承受压力的能力。
有兴趣的请email：marke.chenj@alibaba-inc.com
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/30/spring/">Spring</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-30T17:31:00+08:00" pubdate data-updated="true">Aug 30<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/08/30/spring/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>spring</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/30/java-se-8-lambda/">Java SE 8: Lambda 表达式</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-30T09:04:00+08:00" pubdate data-updated="true">Aug 30<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/08/30/java-se-8-lambda/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Java SE 8在6月13的版本中已经完全了全部的功能。在这些新的功能中，lambda表达式是推动该版本发布的最重要新特性。因为Java第一次尝试引入函数式编程的相关内容。社区对于lambda表达式也期待已久。Lambda表达式的相关内容在JSR 335中定义，本文的内容基于最新的规范和JDK 8 Build b94。 开发环境使用的是Eclipse。</p>

<p>Lambda表达式</p>

<p>要理解lambda表达式，首先要了解的是函数式接口（functional interface）。简单来说，函数式接口是只包含一个抽象方法的接口。比如Java标准库中的java.lang.Runnable和java.util.Comparator都是典型的函数式接口。对于函数式接口，除了可以使用Java中标准的方法来创建实现对象之外，还可以使用lambda表达式来创建实现对象。这可以在很大程度上简化代码的实现。在使用lambda表达式时，只需要提供形式参数和方法体。由于函数式接口只有一个抽象方法，所以通过lambda表达式声明的方法体就肯定是这个唯一的抽象方法的实现，而且形式参数的类型可以根据方法的类型声明进行自动推断。</p>

<p>以Runnable接口为例来进行说明，传统的创建一个线程并运行的方式如下所示：</p>

<pre><code>public void runThread() {
    new Thread(new Runnable() {
    public void run() {
        System.out.println("Run!");
    }
    }).start();
}
</code></pre>

<p>在上面的代码中，首先需要创建一个匿名内部类实现Runnable接口，还需要实现接口中的run方法。如果使用lambda表达式来完成同样的功能，得到的代码非常简洁，如下面所示：</p>

<pre><code>public void runThreadUseLambda() {
    new Thread(() -&gt; {
    System.out.println("Run!");
    }).start();
}
</code></pre>

<p>相对于传统的方式，lambda表达式在两个方面进行了简化：首先是Runnable接口的声明，这可以通过对上下文环境进行推断来得出；其次是对run方法的实现，因为函数式接口中只包含一个需要实现的方法。</p>

<p>Lambda表达式的声明方式比较简单，由形式参数和方法体两部分组成，中间通过“->”分隔。形式参数不需要包含类型声明，可以进行自动推断。当然在某些情况下，形式参数的类型声明是不可少的。方法体则可以是简单的表达式或代码块。</p>

<p>比如把一个整数列表按照降序排列可以用下面的代码来简洁实现：</p>

<pre><code>Collections.sort(list, (x, y) -&gt; y - x);
</code></pre>

<p>Lambda表达式“(x, y) &ndash;> y &ndash; x“实现了java.util.Comparator接口。</p>

<p>在Java SE 8之前的标准库中包含的函数式接口并不多。Java SE 8增加了java.util.function包，里面都是可以在开发中使用的函数式接口。开发人员也可以创建新的函数式接口。最好在接口上使用注解@FunctionalInterface进行声明，以免团队的其他人员错误地往接口中添加新的方法。</p>

<p>下面的代码使用函数式接口java.util.function.Function实现的对列表进行map操作的方法。从代码中可以看到，如果尽可能的使用函数式接口，则代码使用起来会非常简洁。</p>

<pre><code>public class CollectionUtils {
    public static  List map(List input, Function processor) {
    ArrayList result = new ArrayList();
    for (T obj : input) {
        result.add(processor.apply(obj));
    }
    return result;
    }

    public static void main(String[] args) {
    List input = Arrays.asList(new String[] {"apple", "orange", "pear"});
    List lengths = CollectionUtils.map(input, (String v) -&gt; v.length());
    List uppercases = CollectionUtils.map(input, (String v) -&gt; v.toUpperCase());
    }
}
</code></pre>

<p>方法和构造方法引用</p>

<p>方法引用可以在不调用某个方法的情况下引用一个方法。构造方法引用可以在不创建对象的情况下引用一个构造方法。方法引用是另外一种实现函数式接口的方法。在某些情况下，方法引用可以进一步简化代码。比如下面的代码中，第一个forEach方法调用使用的是lambda表达式，第二个使用的是方法引用。两者作用相同，不过使用方法引用的做法更加简洁。</p>

<pre><code>List input = Arrays.asList(new String[] {"apple", "orange", "pear"});
input.forEach((v) -&gt; System.out.println(v));
input.forEach(System.out::println);
</code></pre>

<p>构造方法可以通过名称“new”来进行引用，如下面的代码所示：</p>

<pre><code>List dateValues = Arrays.asList(new Long[] {0L, 1000L});
List dates = CollectionUtils.map(dateValues, Date::new);
</code></pre>

<p>接口的默认方法</p>

<p>Java开发中所推荐的实践是面向接口而不是实现来编程。接口作为不同组件之间的契约，使得接口的实现可以不断地演化。不过接口本身的演化则比较困难。当接口发生变化时，该接口的所有实现类都需要做出相应的修改。如果在新版本中对接口进行了修改，会导致早期版本的代码无法运行。Java对于接口更新的限制过于严格。在代码演化的过程中，一般所遵循的原则是不删除或修改已有的功能，而是添加新的功能作为替代。已有代码可以继续使用原有的功能，而新的代码则可以使用新的功能。但是这种更新方式对于接口是不适用的，因为往一个接口中添加新的方法也会导致已有代码无法运行。</p>

<p>接口的默认方法的主要目标之一是解决接口的演化问题。当往一个接口中添加新的方法时，可以提供该方法的默认实现。对于已有的接口使用者来说，代码可以继续运行。新的代码则可以使用该方法，也可以覆写默认的实现。</p>

<p>考虑下面的一个简单的进行货币转换的接口。该接口的实现方式可能是调用第三方提供的服务来完成实际的转换操作。</p>

<pre><code>public interface CurrencyConverter {
    BigDecimal convert(Currency from, Currency to, BigDecimal amount);
}
</code></pre>

<p>该接口在开发出来之后，在应用中得到了使用。在后续的版本更新中，第三方服务提供了新的批量处理的功能，允许在一次请求中同时转换多个数值。最直接的做法是在原有的接口中添加一个新的方法来支持批量处理，不过这样会造成已有的代码无法运行。而默认方法则可以很好的解决这个问题。使用默认方法的新接口如下所示。</p>

<pre><code>public interface CurrencyConverter {
    BigDecimal convert(Currency from, Currency to, BigDecimal amount);

    default List convert(Currency from, Currency to, List amounts) {
    List result = new ArrayList();
        for (BigDecimal amount : amounts) {
        result.add(convert(from, to, amount));
        }
        return result;
    }
}
</code></pre>

<p>新添加的方法使用default关键词来修饰，并可以有自己的方法体。</p>

<p>默认方法的另外一个作用是实现行为的多继承。Java语言只允许类之间的单继承关系，但是一个类可以实现多个接口。在默认方法引入之后，接口中不仅可以包含变量和方法声明，还可以包含方法体，也就是行为。通过实现多个接口，一个Java类实际上可以获得来自不同接口的行为。这种功能类似于JavaScript等其他语言中可见的“混入类”（mixin）。实际上，Java中一直存在“常量接口（Constant Interface）”的用法。常量接口中只包含常量的声明。通过实现这样的接口，就可以直接引用这些常量。通过默认方法，可以创建出类似的帮助接口，即接口中包含的都是通过默认方法实现的帮助方法。比如创建一个StringUtils接口包含各种与字符串操作相关的默认方法。通过继承该接口就可以直接使用这些方法。</p>

<p>Java SE 8标准库已经使用默认方法来对集合类中的接口进行更新。比如java.util.Collection接口中新增的默认方法removeIf可以删除集合中满足某些条件的元素。还有java.lang.Iterable接口中新增的默认方法forEach可以遍历集合中的元素，并执行一些操作。这些新增的默认方法大多使用了java.util.function包中的函数式接口，因此可以使用lambda表达式来非常简洁的进行操作。</p>

<p>Lambda表达式是Java SE 8在提高开发人员生产效率上的一个重大改进。通过语法上的改进，可以减少开发人员需要编写和维护的代码数量。<br>
转载：<a href="http://www.infoq.com/cn/articles/Java-se-8-lambda">http://www.infoq.com/cn/articles/Java-se-8-lambda</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/29/curl-command/">Curl Command</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-29T10:12:00+08:00" pubdate data-updated="true">Aug 29<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/08/29/curl-command/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>一、查看网页源码
直接在curl命令后加上网址，就可以看到网页源码。我们以网址www.sina.com为例（选择该网址，主要因为它的网页代码较短）：</p>

<pre><code>curl www.sina.com
</code></pre>

<p>　　<code>&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;
　　&lt;html&gt;&lt;head&gt;
　　&lt;title&gt;301 Moved Permanently&lt;/title&gt;
　　&lt;/head&gt;&lt;body&gt;
　　&lt;h1&gt;Moved Permanently&lt;/h1&gt;
　　&lt;p&gt;The document has moved &lt;a href="http://www.sina.com.cn/"&gt;here&lt;/a&gt;.&lt;/p&gt;
　　&lt;/body&gt;&lt;/html&gt;</code>
如果要把这个网页保存下来，可以使用-o参数，这就相当于使用wget命令了。</p>

<pre><code>curl -o [文件名] www.sina.com
</code></pre>

<p>二、自动跳转
有的网址是自动跳转的。使用-L参数，curl就会跳转到新的网址。</p>

<pre><code>curl -L www.sina.com
</code></pre>

<p>键入上面的命令，结果就自动跳转为www.sina.com.cn。
三、显示头信息
-i参数可以显示http response的头信息，连同网页代码一起。</p>

<pre><code>curl -i www.sina.com
</code></pre>

<p>　　<code>HTTP/1.0 301 Moved Permanently
　　Date: Sat, 03 Sep 2011 23:44:10 GMT
　　Server: Apache/2.0.54 (Unix)
　　Location: http://www.sina.com.cn/
　　Cache-Control: max-age=3600
　　Expires: Sun, 04 Sep 2011 00:44:10 GMT
　　Vary: Accept-Encoding
　　Content-Length: 231
　　Content-Type: text/html; charset=iso-8859-1
　　Age: 3239
　　X-Cache: HIT from sh201-9.sina.com.cn
　　Connection: close
　　&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;
　　&lt;html&gt;&lt;head&gt;
　　&lt;title&gt;301 Moved Permanently&lt;/title&gt;
　　&lt;/head&gt;&lt;body&gt;
　　&lt;h1&gt;Moved Permanently&lt;/h1&gt;
　　&lt;p&gt;The document has moved &lt;a href="http://www.sina.com.cn/"&gt;here&lt;/a&gt;.&lt;/p&gt;
　　&lt;/body&gt;&lt;/html&gt;</code>
-I参数则是只显示http response的头信息。
四、显示通信过程
-v参数可以显示一次http通信的整个过程，包括端口连接和http request头信息。
　　curl -v www.sina.com
　<code>　* About to connect() to www.sina.com port 80 (#0)
　　* Trying 61.172.201.195... connected
　　* Connected to www.sina.com (61.172.201.195) port 80 (#0)
　　&gt; GET / HTTP/1.1
　　&gt; User-Agent: curl/7.21.3 (i686-pc-linux-gnu) libcurl/7.21.3 OpenSSL/0.9.8o zlib/1.2.3.4 libidn/1.18
　　&gt; Host: www.sina.com
　　&gt; Accept: */*
　　&gt;
　　* HTTP 1.0, assume close after body
　　&lt; HTTP/1.0 301 Moved Permanently
　　&lt; Date: Sun, 04 Sep 2011 00:42:39 GMT
　　&lt; Server: Apache/2.0.54 (Unix)
　　&lt; Location: http://www.sina.com.cn/
　　&lt; Cache-Control: max-age=3600
　　&lt; Expires: Sun, 04 Sep 2011 01:42:39 GMT
　　&lt; Vary: Accept-Encoding
　　&lt; Content-Length: 231
　　&lt; Content-Type: text/html; charset=iso-8859-1
　　&lt; X-Cache: MISS from sh201-19.sina.com.cn
　　&lt; Connection: close
　　&lt;
　　&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;
　　&lt;html&gt;&lt;head&gt;
　　&lt;title&gt;301 Moved Permanently&lt;/title&gt;
　　&lt;/head&gt;&lt;body&gt;
　　&lt;h1&gt;Moved Permanently&lt;/h1&gt;
　　&lt;p&gt;The document has moved &lt;a href="http://www.sina.com.cn/"&gt;here&lt;/a&gt;.&lt;/p&gt;
　　&lt;/body&gt;&lt;/html&gt;
　　* Closing connection #0</code>
如果你觉得上面的信息还不够，那么下面的命令可以查看更详细的通信过程。</p>

<pre><code>curl --trace output.txt www.sina.com
</code></pre>

<p>或者</p>

<pre><code>curl --trace-ascii output.txt www.sina.com
</code></pre>

<p>运行后，请打开output.txt文件查看。
五、发送表单信息
发送表单信息有GET和POST两种方法。GET方法相对简单，只要把数据附在网址后面就行。</p>

<pre><code>curl example.com/form.cgi?data=xxx
</code></pre>

<p>POST方法必须把数据和网址分开，curl就要用到&mdash;data参数。</p>

<pre><code>curl --data "data=xxx" example.com/form.cgi
</code></pre>

<p>如果你的数据没有经过表单编码，还可以让curl为你编码，参数是&mdash;data-urlencode。</p>

<pre><code>curl --data-urlencode "date=April 1" example.com/form.cgi
</code></pre>

<p>六、HTTP动词
curl默认的HTTP动词是GET，使用-X参数可以支持其他动词。</p>

<pre><code>curl -X POST www.example.com
curl -X DELETE www.example.com
</code></pre>

<p>七、文件上传
假定文件上传的表单是下面这样：
　　<code>&lt;form method="POST" enctype='multipart/form-data' action="upload.cgi"&gt;
　　　　&lt;input type=file name=upload&gt;
　　　　&lt;input type=submit name=press value="OK"&gt;
　　&lt;/form&gt;</code>
你可以用curl这样上传文件：</p>

<pre><code>curl --form upload=@localfilename --form press=OK [URL]
</code></pre>

<p>八、Referer字段
有时你需要在http request头信息中，提供一个referer字段，表示你是从哪里跳转过来的。</p>

<pre><code>curl --referer http://www.example.com http://www.example.com
</code></pre>

<p>九、User Agent字段
这个字段是用来表示客户端的设备信息。服务器有时会根据这个字段，针对不同设备，返回不同格式的网页，比如手机版和桌面版。
iPhone4的User Agent是
　　Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_0 like Mac OS X; en-us) AppleWebKit/532.9 (KHTML, like Gecko) Version/4.0.5 Mobile/8A293 Safari/6531.22.7
curl可以这样模拟：</p>

<pre><code>curl --user-agent "[User Agent]" [URL]
</code></pre>

<p>十、cookie
使用&mdash;cookie参数，可以让curl发送cookie。</p>

<pre><code>curl --cookie "name=xxx" www.example.com
</code></pre>

<p>至于具体的cookie的值，可以从http response头信息的Set-Cookie字段中得到。
十一、增加头信息
有时需要在http request之中，自行增加一个头信息。&mdash;header参数就可以起到这个作用。</p>

<pre><code>curl --header "xxx: xxxxxx" http://example.com
</code></pre>

<p>十二、HTTP认证
有些网域需要HTTP认证，这时curl需要用到&mdash;user参数。</p>

<pre><code>curl --user name:password example.com
curl www.sina.com view page
curl -o index.html www.sina.com download page
curl -L www.sina.com redirect page
curl -i www.sina.com view head&amp;content
curl -v www.sina.com traceinfo
curl --trace output.txt www.sina.com
curl --trace-ascii output.txt www.sina.com
</code></pre>

<p>登录到认证页面：</p>

<pre><code>openssl pkcs12 -in  key.pfx -out all.pem -nodes
curl -L -s -k --cert all.pem www.xxx.com
</code></pre>

<p>常用curl实例</p>

<p>1，抓取页面内容到一个文件中</p>

<pre><code>curl -o home.html http://www.ilehao.com
</code></pre>

<p>2，用-O（大写的），后面的url要具体到某个文件，不然抓不下来。我们还可以用正则来抓取东西</p>

<pre><code>curl -O http://www.ilehao.com/images/blogImgs/rtb.jpg
curl -O http://www.ilehao.com/images/blogImgs/[a-z].jpg
</code></pre>

<p>3，模拟表单信息，模拟登录，保存cookie信息</p>

<pre><code>curl -c ./cookie_c.txt -F log=aaaa -F pwd=****** http://www.ilehao.com
</code></pre>

<p>4，模拟表单信息，模拟登录，保存头信息</p>

<pre><code>curl -D ./cookie_D.txt -F log=aaaa -F pwd=****** http://www.ilehao.com
</code></pre>

<p>-c(小写)产生的cookie和-D里面的cookie是不一样的。</p>

<p>5，使用cookie文件</p>

<pre><code>curl -b ./cookie_c.txt  http://www.ilehao.com
</code></pre>

<p>6，断点续传，-C(大写的)</p>

<pre><code>curl -C -O http://www.ilehao.com/wp-content/uploads/2010/09/compare_varnish.jpg
</code></pre>

<p>7，传送数据,最好用登录页面测试，因为你传值过去后，curl回抓数据，你可以看到你传值有没有成功</p>

<pre><code>curl -d log=aaaa  http://www.ilehao.com/wp-login.php
</code></pre>

<p>8，显示抓取错误，下面这个例子，很清楚的表明了。</p>

<pre><code>curl -f http://www.ilehao.com/asdf
curl: (22) The requested URL returned error: 404
curl http://www.ilehao.com/asdf
</code></pre>

<p><code>&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;404,not found&lt;/TITLE&gt;
。。。。。。。。。。。。</code></p>

<p>9，伪造来源地址，有的网站会判断，请求来源地址。</p>

<pre><code>curl -e http://localhost http://www.ilehao.com
</code></pre>

<p>10，当我们经常用curl去搞人家东西的时候，人家会把你的IP给屏蔽掉的,这个时候,我们可以用代理</p>

<pre><code>curl -x 24.10.28.84:32779 -o home.html http://www.ilehao.com
</code></pre>

<p>11，比较大的东西，我们可以分段下载</p>

<pre><code>curl -r 0-100 -o img.part1 http://www.ilehao.com/wp-content/uploads/2010/09/compare_varnish.jpg
</code></pre>

<p><code>% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
Dload  Upload   Total   Spent    Left  Speed
100   101  100   101    0     0    105      0 --:--:-- --:--:-- --:--:--     0
curl -r 100-200 -o img.part2 http://www.ilehao.com/wp-content/uploads/2010/09/compare_varnish.jpg
% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
Dload  Upload   Total   Spent    Left  Speed
100   101  100   101    0     0     57      0  0:00:01  0:00:01 --:--:--     0
curl -r 200- -o img.part3 http://www.ilehao.com/wp-content/uploads/2010/09/compare_varnish.jpg
% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
Dload  Upload   Total   Spent    Left  Speed
100  104k  100  104k    0     0  52793      0  0:00:02  0:00:02 --:--:-- 88961
ls |grep part | xargs du -sh
4.0K    one.part1
112K    three.part3
4.0K    two.part2</code>
用的时候，把他们cat一下就OK了,cat img.part* >img.jpg</p>

<pre><code>curl -s -o aaa.jpg  http://www.ilehao.com/wp-content/uploads/2010/09/compare_varnish.jpg
</code></pre>

<p>13，显示下载进度条</p>

<pre><code>curl -# -O  http://www.ilehao.com/wp-content/uploads/2010/09/compare_varnish.jpg
</code></pre>

<h6>################################################################## 100.0%</h6>

<p>14,通过ftp下载文件</p>

<pre><code>curl -u 用户名:密码 -O http://www.ilehao.com/demo/curtain/bbstudy_files/style.css
</code></pre>

<p><code>% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
Dload  Upload   Total   Spent    Left  Speed
101  1934  101  1934    0     0   3184      0 --:--:-- --:--:-- --:--:--  7136</code></p>

<p>或者用下面的方式</p>

<pre><code>curl -O ftp://用户名:密码@ip:port/demo/curtain/bbstudy_files/style.css
</code></pre>

<p>15，通过ftp上传</p>

<pre><code>curl -O ftp://用户名:密码@ip:port/demo/curtain/bbstudy_files/style.css
</code></pre>

<p>12，不会显示下载进度信息</p>

<pre><code>curl -T test.sql ftp://用户名:密码@ip:port/demo/curtain/bbstudy_files/
</code></pre>

<p>-a/&mdash;append 上传文件时，附加到目标文件<br>
-A/&mdash;user-agent <string> 设置用户代理发送给服务器<br><br/>
&ndash; anyauth 可以使用“任何”身份验证方法<br>
-b/&mdash;cookie &lt;name=string/file> cookie字符串或文件读取位置<br><br/>
&ndash; basic 使用HTTP基本验证 <br>
-B/&mdash;use-ascii 使用ASCII /文本传输<br><br/>
-c/&mdash;cookie-jar <file> 操作结束后把cookie写入到这个文件中  <br>
-C/&mdash;continue-at <offset> 断点续转<br>
-d/&mdash;data <data> HTTP POST方式传送数据<br>
&mdash;data-ascii <data> 以ascii的方式post数据<br>
&mdash;data-binary <data> 以二进制的方式post数据<br>
&mdash;negotiate 使用HTTP身份验证<br>
&mdash;digest 使用数字身份验证<br>
&mdash;disable-eprt 禁止使用EPRT或LPRT<br>
&mdash;disable-epsv 禁止使用EPSV<br>
-D/&mdash;dump-header <file> 把header信息写入到该文件中<br>
&mdash;egd-file <file> 为随机数据(SSL)设置EGD socket路径<br>
&mdash;tcp-nodelay 使用TCP_NODELAY选项<br>
-e/&mdash;referer 来源网址<br>
-E/&mdash;cert &lt;cert[:passwd]> 客户端证书文件和密码 (SSL)<br>
&mdash;cert-type <type> 证书文件类型 (DER/PEM/ENG) (SSL)<br>
&mdash;key <key> 私钥文件名 (SSL)<br>
&mdash;key-type <type> 私钥文件类型 (DER/PEM/ENG) (SSL)<br>
&mdash;pass <pass> 私钥密码 (SSL)<br>
&mdash;engine <eng> 加密引擎使用 (SSL). &ldquo;&mdash;engine list&rdquo; for list<br>
&mdash;cacert <file> CA证书 (SSL)<br>
&mdash;capath <directory> CA目录 (made using c_rehash) to verify peer against (SSL)<br>
&mdash;ciphers <list> SSL密码<br>
&mdash;compressed 要求返回是压缩的形势 (using deflate or gzip)<br>
&mdash;connect-timeout <seconds> 设置最大请求时间<br>
&mdash;create-dirs 建立本地目录的目录层次结构<br>
&mdash;crlf 上传是把LF转变成CRLF<br>
-f/&mdash;fail 连接失败时不显示http错误<br>
&mdash;ftp-create-dirs 如果远程目录不存在，创建远程目录<br>
&mdash;ftp-method [multicwd/nocwd/singlecwd] 控制CWD的使用<br>
&mdash;ftp-pasv 使用 PASV/EPSV 代替端口<br>
&mdash;ftp-skip-pasv-ip 使用PASV的时候,忽略该IP地址<br>
&mdash;ftp-ssl 尝试用 SSL/TLS 来进行ftp数据传输<br>
&mdash;ftp-ssl-reqd 要求用 SSL/TLS 来进行ftp数据传输<br>
-F/&mdash;form &lt;name=content> 模拟http表单提交数据<br>
-form-string &lt;name=string> 模拟http表单提交数据<br>
-g/&mdash;globoff 禁用网址序列和范围使用{}和[]<br>
-G/&mdash;get 以get的方式来发送数据<br>
-h/&mdash;help 帮助<br>
-H/&mdash;header <line>自定义头信息传递给服务器<br>
&mdash;ignore-content-length 忽略的HTTP头信息的长度<br>
-i/&mdash;include 输出时包括protocol头信息<br>
-I/&mdash;head 只显示文档信息<br>
从文件中读取-j/&mdash;junk-session-cookies忽略会话Cookie<br>
&ndash; 界面<interface>指定网络接口/地址使用<br>
&ndash; krb4 &lt;级别>启用与指定的安全级别krb4<br>
-j/&mdash;junk-session-cookies 读取文件进忽略session cookie<br>
&mdash;interface <interface> 使用指定网络接口/地址<br>
&mdash;krb4 <level> 使用指定安全级别的krb4<br>
-k/&mdash;insecure 允许不使用证书到SSL站点<br>
-K/&mdash;config 指定的配置文件读取<br>
-l/&mdash;list-only 列出ftp目录下的文件名称<br>
&mdash;limit-rate <rate> 设置传输速度<br>
&mdash;local-port<NUM> 强制使用本地端口号<br>
-m/&mdash;max-time <seconds> 设置最大传输时间<br>
&mdash;max-redirs <num> 设置最大读取的目录数<br>
&mdash;max-filesize <bytes> 设置最大下载的文件总量<br>
-M/&mdash;manual 显示全手动<br>
-n/&mdash;netrc 从netrc文件中读取用户名和密码<br>
&mdash;netrc-optional 使用 .netrc 或者 URL来覆盖-n<br>
&mdash;ntlm 使用 HTTP NTLM 身份验证<br>
-N/&mdash;no-buffer 禁用缓冲输出<br>
-o/&mdash;output 把输出写到该文件中<br>
-O/&mdash;remote-name 把输出写到该文件中，保留远程文件的文件名<br>
-p/&mdash;proxytunnel 使用HTTP代理<br>
&mdash;proxy-anyauth 选择任一代理身份验证方法<br>
&mdash;proxy-basic 在代理上使用基本身份验证<br>
&mdash;proxy-digest 在代理上使用数字身份验证<br>
&mdash;proxy-ntlm 在代理上使用ntlm身份验证<br>
-P/&mdash;ftp-port <address> 使用端口地址，而不是使用PASV<br>
-Q/&mdash;quote <cmd>文件传输前，发送命令到服务器<br>
-r/&mdash;range <range>检索来自HTTP/1.1或FTP服务器字节范围<br>
&mdash;range-file 读取（SSL）的随机文件<br>
-R/&mdash;remote-time 在本地生成文件时，保留远程文件时间<br>
&mdash;retry <num> 传输出现问题时，重试的次数   <br>
&mdash;retry-delay <seconds> 传输出现问题时，设置重试间隔时间 <br><br/>
&mdash;retry-max-time <seconds> 传输出现问题时，设置最大重试时间  <br>
-s/&mdash;silent静音模式。不输出任何东西   <br>
-S/&mdash;show-error 显示错误   <br>
&mdash;socks4 &lt;host[:port]> 用socks4代理给定主机和端口 <br/>
&mdash;socks5 &lt;host[:port]> 用socks5代理给定主机和端口 <br/>
&mdash;stderr <file> <br/>
-t/&mdash;telnet-option &lt;OPT=val> Telnet选项设置 <br/>
&mdash;trace <file> 对指定文件进行debug<br/>
&mdash;trace-ascii <file> Like &mdash;跟踪但没有hex输出 <br/>
&mdash;trace-time 跟踪/详细输出时，添加时间戳 <br/>
-T/&mdash;upload-file <file> 上传文件<br/>
&mdash;url <URL> Spet URL to work with <br/>
-u/&mdash;user &lt;user[:password]>设置服务器的用户和密码<br/>
-U/&mdash;proxy-user &lt;user[:password]>设置代理用户名和密码 <br/>
-v/&mdash;verbose <br/>
-V/&mdash;version 显示版本信息 <br/>
-w/&mdash;write-out [format]什么输出完成后 <br/>
-x/&mdash;proxy &lt;host[:port]>在给定的端口上使用HTTP代理<br/>
-X/&mdash;request <command>指定什么命令<br/>
-y/&mdash;speed-time 放弃限速所要的时间。默认为30 <br/>
-Y/&mdash;speed-limit 停止传输速度的限制，速度时间&#8217;秒<br/>
-z/&mdash;time-cond 传送时间设置 <br/>
-0/&mdash;http1.0 使用HTTP 1.0 <br/>
-1/&mdash;tlsv1 使用TLSv1（SSL）<br/>
-2/&mdash;sslv2 使用SSLv2的（SSL）<br/>
-3/&mdash;sslv3 使用的SSLv3（SSL）<br/>
&mdash;3p-quote like -Q for the source URL for 3rd party transfer<br/>
&mdash;3p-url 使用url，进行第三方传送<br/>
&mdash;3p-user 使用用户名和密码，进行第三方传送<br/>
-4/&mdash;ipv4 使用IP4<br/>
-6/&mdash;ipv6 使用IP6<br/>
&ndash;#/&mdash;progress-bar 用进度条显示当前的传送状态</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>About Me</h1>
  <p><img src="/images/blogImgs/self.jpg"></p>
  <p>java程序员，老猿人，孩子他爸</p>
  <p>爱篮球，爱Google, 爱折腾</p>
  <p>喜欢开源的东西, 喜欢读书和思考</p>
  <p><img src="/images/email.png"  alt="milehao@gmail.com" /></p>
</section>
<section>
  <h1>Sina 微博</h1>
<iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=3&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=2235818362&verifier=f873c807&dpc=1"></iframe>
</section><section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/03/27/thread-wait-sleep/">Thread.sleep()与Object.wait()的区别</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/03/21/string-intern/">我对String及String.intern()的理解</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/03/19/linux-apache-grep-log/">linux下grep分析APACHE 服务器日志 命令集合</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/03/18/special-character/">特殊字符的含义</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/03/04/idp/">2014个人发展计划(IDP)</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Tag Cloud</h1>
    <span id="tag-cloud"></span>
</section><section>
  <ul id="categories">
    
  </ul>
</section><section>
  <h1>最新评论</h1>
  <script type="text/javascript" src="http://lehao.disqus.com/recent_comments_widget.js?num_items=5&hide_avatars=0&avatar_size=32&excerpt_length=200"></script>
</section><section>
<h1>My Douban</h1>
<div>
<script type="text/javascript" src="http://www.douban.com/service/badge/ilehao/?show=wishlist&n=9&columns=3&hidelogo=yes&cat=movie|book" ></script>
</div>
</section>


  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - 乐皓 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <script src="http://s21.cnzz.com/stat.php?id=4841109&web_id=4841109&show=pic" language="JavaScript"></script>
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-43609148-1', 'ilehao.com');
  ga('send', 'pageview');

</script>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'lehao';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
